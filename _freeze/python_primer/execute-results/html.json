{
  "hash": "289c34f563193e5d8143405d90026b1f",
  "result": {
    "engine": "jupyter",
    "markdown": "# A Python primer {#sec-python_primer}\n\n:::{.callout-note}\nFrom now on, we will assume that you have a working Python installation running on your computer. You can check this by typing the following into a terminal/console/command line:\n\n\n\n```{terminal}\npython --version\n```\n\n\n\nIf the version number starts with a 3, you're all set. If not, please consider one of the many tutorials online on how to install Python.\n:::\n\n## Variables and types\n\nVariable assignment in Python is straight-forward. You choose a name for the variable, and assign a value to it using the `=` operator, for example:\n\n::: {#cef17d4e .cell execution_count=1}\n``` {.python .cell-code}\nx = 100\n```\n:::\n\n\nassigns the value `100` to the variable `x`. If we call the variable now, \nwe can see that it has the value we assigned to it:\n\n::: {#b79d1aa9 .cell execution_count=2}\n``` {.python .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n100\n```\n:::\n:::\n\n\nOf course, we can also assign things other than numbers, for example:\n\n::: {#49e64804 .cell execution_count=3}\n``` {.python .cell-code}\nname = \"Fabian\"\n```\n:::\n\n\nWhat we assigned to the variable `name` is called a _string_,\nit has the value `\"Fabian\"`. Strings are sequences of characters.\n\n::: {.callout-tip}\nNote that `\"Fabian\"` is enclosed by double-quotes.\nWhy is this the case? Why could we not just type `name = Fabian`?\n:::\n\nWe can also assign a list of things to a variable:\n\n::: {#f08cad9e .cell execution_count=4}\n``` {.python .cell-code}\nmylist = [1, 2, 3, \"A\", \"B\", \"C\"]\n```\n:::\n\n\nLists are enclosed by square brackets. As you can see, Python allows you \nto store any kind of data in lists (here: integer numbers and character strings). \nHowever, it is good practice to include only items of the same type in \nlists---you'll understand later why.\n\nAnother structured data type in python are dictionaries. Dictionaries are\ncollections of key-value pairs. For example, a dictionary `addresses` \ncould store the email addresses of certain people:\n\n::: {#dbe9a2b4 .cell execution_count=5}\n``` {.python .cell-code}\naddresses = {\n    \"Andrew\" : \"andrew@example.com\",\n    \"Zoe\" : \"zoe@example.com\"\n}\n```\n:::\n\n\nNow, if we wanted to look up Zoe's email address, we could to so with:\n\n::: {#7c0e9a1f .cell execution_count=6}\n``` {.python .cell-code}\naddresses[\"Zoe\"]\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n'zoe@example.com'\n```\n:::\n:::\n\n\n## On repeat\n\nCoding something is only useful if you can't do the job as fast or as efficient by yourself. Especially when it comes to repeating the same little thing many, many times, knowing how to code comes in handy.\n\nAs a simple example, imagine you want to write down all numbers from 1 to 10, or from 1 to 100, or... you get the idea.\nIn Python, you would do it as follows:\n\n::: {#e8435e9a .cell execution_count=7}\n``` {.python .cell-code}\nfor i in range(10):\n    print(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n```\n:::\n:::\n\n\nYou see that this is not exactly what we wanted. We're seeing numbers from 0 to 9, \neach one being printed on a new line. But what we wanted was all numbers from 1 to 10. \nBefore we fix the code to produce the desired result, let's explain the bits and pieces of the code above. \n\nWhat we just did was to use a so-called _for-loop_, probably the most common way to repeat things in Python. \nFirst we create an _iterator variable_ `i` (we could have named any other variable name as well), \nwhich takes its value from the list of numbers specified by `range(10)`. \nIf only one number `n` is provided to `range(n)`, it will enumerate all \nnumbers from 0 to `n-1`. If instead two arguments are provided, \nthe first one determines the starting number, and the second one stands\nfor the terminating number minus one---confusing, right? \n\nSo, in order to enumerate all numbers from 1 to 10, we have to write `range(1,11)`. \nAdditionally, we can use the `end` keyword of the `print` function\nthat allows us to print all numbers in one line, separated only\nby a single white space instead of each one on a new line.\n\n::: {#27d98fff .cell execution_count=8}\n``` {.python .cell-code}\nfor i in range(1,11):\n    print(i, end=\" \")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1 2 3 4 5 6 7 8 9 10 \n```\n:::\n:::\n\n\nVoil√†!\n\n## Just in case\n\nOften we encounter a situation where we would execute some code **only if** certain \nconditions are met. In python, this is done with the `if` statement. For example, \nif we want to only print the even numbers in the range from 1 to 10, we \ncould adapt the code from above as follows:\n\n::: {#d0ab1643 .cell execution_count=9}\n``` {.python .cell-code}\nfor i in range(1,11):\n    if i % 2 == 0:\n        print(i, \"is even\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2 is even\n4 is even\n6 is even\n8 is even\n10 is even\n```\n:::\n:::\n\n\nYou can read this as \"if the remainder of dividing i by 2 is zero, then print 'i is even'\".\n\nNow, we could also want to print a similar statement in the case that `i` is odd:\n\n::: {#672b09a2 .cell execution_count=10}\n``` {.python .cell-code}\nfor i in range(1,11):\n    if i % 2 == 0:\n        print(i, \"is even\")\n    else:\n        print(i, \"is odd\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1 is odd\n2 is even\n3 is odd\n4 is even\n5 is odd\n6 is even\n7 is odd\n8 is even\n9 is odd\n10 is even\n```\n:::\n:::\n\n\nAnd, finally, we could also have more than just one condition. An if-statement\nallows for arbitrary many if-else clauses, with which we can formulate several different \nconditions by writing `elif` (shorthand for 'or else if'):\n\n::: {#8bd8b2ea .cell execution_count=11}\n``` {.python .cell-code}\nfor i in range(1,11):\n    if i % 2 == 0:\n        print(i, \"is even\")\n    elif i % 3 == 0:\n        print(i, \"is divisible by 3\")\n    else:\n        print(i, \"is odd\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1 is odd\n2 is even\n3 is divisible by 3\n4 is even\n5 is odd\n6 is even\n7 is odd\n8 is even\n9 is divisible by 3\n10 is even\n```\n:::\n:::\n\n\nWe now know when a number is even and when it is divisible by 3.\nBut what about numbers that are _both_ even _and_ divisible by 3? \nWe just add another condition to the `elif` statement and enclose each condition in parentheses, so that Python knows how things group together:\n\n::: {#c927a881 .cell execution_count=12}\n``` {.python .cell-code}\nfor i in range(1,11):\n    if i % 2 == 0:\n        print(i, \"is even\")\n    elif (i % 2 == 0) and (i % 3 == 0):\n        print(i, \"is even and divisible by 3\")\n    else:\n        print(i, \"is odd\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1 is odd\n2 is even\n3 is odd\n4 is even\n5 is odd\n6 is even\n7 is odd\n8 is even\n9 is odd\n10 is even\n```\n:::\n:::\n\n\nWhy did this not work? The number 6 is even _and_ divisible by 3!\nThe reason is that the three statements (`if`, `elif`, and `else`)\nare being executed in the order that we wrote them down. \nThat means, that Python will first check for each number whether \nit is even (and nothing more), and if it is, it will follow the instruction to print \nit and go on to the next number. So, once we arrived at 6, the programm \nwill only check if the number is even. That is not the desired result and we have to \nmake a little change to it. We will switch the conditions in the `if` and `elif` \nstatements:\n\n::: {#a217506a .cell execution_count=13}\n``` {.python .cell-code}\nfor i in range(1,11):\n    if (i % 2 == 0) and (i % 3 == 0):\n        print(i, \"is even and divisible by 3\")\n    elif i % 2 == 0:\n        print(i, \"is even\")\n    else:\n        print(i, \"is odd\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1 is odd\n2 is even\n3 is odd\n4 is even\n5 is odd\n6 is even and divisible by 3\n7 is odd\n8 is even\n9 is odd\n10 is even\n```\n:::\n:::\n\n\nNow it works! Note that new never specified any conditions for the `else`\nstatement. This is because whatever follows it will be executed in case \nnone of the conditions in `if` or `elif` are met.\n\n## Functions\n\nWith more and more experience in programming, \nit is likely that your code will become more and more complex.\nThat means that it will become harder to keep track of what every piece \nof it is supposed to do. A good strategy to deal with this is to aim \nfor writing code that is _modular_: it can be broken down into smaller \nunits (modules) that are easier to understand. Moreover, it is sometimes \nnecessary to reuse the same code several times. It would, however, \nbe inefficient to write the same lines over and over again. \nWith your code being modular you can wrap the pieces that you\nneed in several places into a _function_. \n\nLet's look at an example! Assume, your (fairly) complex code involves\ncalculating the sum of the squares of two numbers. \nIn Python, we use the `+` operator to calculate sums and the `**` operator \nto raise a number to a certain power (`**2` for the square of a number). \n\n::: {#35db7f9f .cell execution_count=14}\n``` {.python .cell-code}\nx = 3\ny = 5\n\nsum_of_squares = x**2 + y**2\n```\n:::\n\n\nThe variable `sum_of_squares` now contains the sum of squares of `x=3` and `y=5`. \nWe can inspect the result by calling the variable:\n\n::: {#e728e202 .cell execution_count=15}\n``` {.python .cell-code}\nsum_of_squares \n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\n34\n```\n:::\n:::\n\n\nNow, imagine that you would have to do the same calculation \nseveral times for different combinations of values for `x` and `y` \n(and always keeping in mind that this stands in for much more \ncomplex examples with several lines of code). We can code this in a function:\n\n::: {#0ef139be .cell execution_count=16}\n``` {.python .cell-code}\ndef func_sum_of_squares(x, y):\n    return x**2 + y**2\n```\n:::\n\n\nNow, each time we want to calculate a sum of squares, we can do so by simply invoking \n\n::: {#ad584f3c .cell execution_count=17}\n``` {.python .cell-code}\nfunc_sum_of_squares(5,4)\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\n41\n```\n:::\n:::\n\n\nAnd, of course, we could chose a shorter name for the function as well,\nalthough I would recommend to always use function names that make clear what\nthe function does:\n\n::: {#38c8d92d .cell execution_count=18}\n``` {.python .cell-code}\nf = func_sum_of_squares\n\nf(5,4)\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\n41\n```\n:::\n:::\n\n\n## Libraries you'll love\n\nLuckily, you don't have to programm all functions by yourself.\nThere is a huge community of Python programmers out there that \nworks and collaborates on several _libraries_. A library is (more or less)\nsimply a collection of certain functions (and some more, but we don't get into this here). This means, instead of writing a function yourself, you can rely on functions that someone else has programmed.\n\n::: {.callout-caution}\nWhether a Python library or function does actually do what it promises is\nanother story. Popular libraries with tens of thousands of users \nare very trust-worthy because you can be almost sure that someone would \nhave noticed erroneous behavior. But it is certainly possible that \nbadly-maintained libraries contain errors. So be prudent when using the code of others.\n:::\n\n### NumPy\n\nOne of the most popular Python libaries is [NumPy](https://numpy.org/) for numerical computations. We will rely a lot on the functions in this library, especially in order to draw random samples---more on this later!\nTo use the functions or variables from this library, they have to be _imported_ so that you can use them. There are several ways to do this.\nFor example, you can import the libary entirely:\n\n::: {#97d84ce2 .cell execution_count=19}\n``` {.python .cell-code}\nimport numpy\n```\n:::\n\n\nNow, you can use the (approximated) value of $\\pi$ stored in this library by typing \n\n::: {#6f45b22e .cell execution_count=20}\n``` {.python .cell-code}\nnumpy.pi\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\n3.141592653589793\n```\n:::\n:::\n\n\nA different way is to just import everything from the library by writing \n\n::: {#e742b883 .cell execution_count=21}\n``` {.python .cell-code}\nfrom numpy import * \n```\n:::\n\n\nHere, the `*` stands for 'everything'. Now, to use the value of $\\pi$ we could simply type\n\n::: {#d8cfad7f .cell execution_count=22}\n``` {.python .cell-code}\npi\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\n3.141592653589793\n```\n:::\n:::\n\n\nThis is, however discouraged for the following reason: imagine we had another library, `numpy2` that also stores the value of $\\pi$, but less precisely (e.g. only as `3.14`). If we write \n\n::: {#3591935c .cell execution_count=23}\n``` {.python .cell-code}\nfrom numpy import * \nfrom numpy2 import * \n```\n:::\n\n\nWe would have imported the variables holding the value of $\\pi$ from both libraries. But, because they have the same name `pi`. In this case, `pi` would equal `3.14` because we imported `numpy2` last. This is confusing and shouldn't be so! To avoid this, it is better to keep references to imported libraries explicit. In order not to have to type too much (we're all lazy, after all), we can define an alias for the library.\n\n::: {#52e726f8 .cell execution_count=24}\n``` {.python .cell-code}\nimport numpy as np\nnp.pi\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```\n3.141592653589793\n```\n:::\n:::\n\n\nAll functions of NumPy are now accessible with the prefix `np.`. \n\n### Pandas\n\n[TODO]\n\n### Matplotlib\n\n[TODO]\n\n### Summary\n\nYou can choose any alias when importing a library (it can even by longer than the library name) but certain conventions have emerged that you're encouraged to follow. Importing the most commonly used Python libraries for data-science tasks (\"The data science triad\"), use the following:\n\n::: {#0ab2d3f8 .cell execution_count=25}\n``` {.python .cell-code}\nimport numpy as np # for numerical computations\nimport pandas as pd # for tabular data \nimport matplotlib.pyplot as plt # for data visualization\n```\n:::\n\n\nWe will use all three of them in the following chapters and you'll learn to love them.\n\n:::{.callout-tip title=\"Concepts covered\"}\n\n* variables\n* types (integers, strings, lists, dictionaries)\n* functions\n* libraries, importing and aliases\n:::\n\n",
    "supporting": [
      "python_primer_files"
    ],
    "filters": [],
    "includes": {}
  }
}