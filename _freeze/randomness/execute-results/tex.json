{
  "hash": "83140271bdb7b91b94cdf4d74e3e90e6",
  "result": {
    "engine": "jupyter",
    "markdown": "# Randomness and order {#sec-randomness}\n\nThis course is about music and evolution,\nspecifically about using computational models\nto better understand the mechanisms underlying certain evolutionary\nprocesses. In order to do so, we will often run simulations \nto observe and interpret the resulting scenarios against the backdrop\nof our modeling assumptions and our domain knowledge.\n\nSimulations are useful because for many situations we \nare not able to provide deterministic mathematical formulae to obtain \noutcomes from inputs. Rather, we incorporate our knowledge about the world\nin a computational model and use randomness to include the inherent uncertainty\nabout the exact outcomes of the simulations.\n\n:::{.callout}\nAdd section on probability.\n:::\n\nBut randomness is a difficult concept to capture. \nFor the purpose of this book, we will simulate a speficic kind of randomness\nby sampling from a certain set of items.\nLess technically, we can imagine a bag with a certain number of balls in it,\neach having a certain color (multiple balls can have the same color). \nA _random uniform sample with replacement_ then corresponds to picking a \nball from the bag without looking in it and putting it back in the bag.\n\n## Random draws from a bag\n\nLet's try this in Python. We will use the `random` modul of the _NumPy_ library:\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nrng = np.random.default_rng() # initialize a default random generator\n\nbag = range(4)\nball = rng.choice(bag)\n\nprint(ball)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3\n```\n:::\n:::\n\n\nIf this draw were really random, we would expect that each number is equally likely.\nWe can test this by repeating this procedure again and again, tallying the result each time.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nsamples = []\n\nfor i in range(1000):\n    ball = rng.choice(bag)\n    samples.append(ball)\n\ns = pd.Series(samples)\n\nprint(s.head(10))\nprint(s.value_counts().sort_index())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0    3\n1    1\n2    3\n3    2\n4    2\n5    0\n6    2\n7    3\n8    2\n9    1\ndtype: int64\n0    249\n1    261\n2    245\n3    245\ndtype: int64\n```\n:::\n:::\n\n\nThe number are not exactly the same but pretty close. If we would continue sampling\nfrom our bag, they would get more and more similar to one another.\nIt is easier to understand this by visualizing it.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ns.value_counts().sort_index().plot(kind=\"bar\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](randomness_files/figure-pdf/cell-4-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\nNow, what if the numbers in the bag were not just numbered,\nbut had different colors? Let's assume we have another bag, `bag2`,\nwith 4 balls, three brown, one blue:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nbag2 = [ \"blue\", \"blue\", \"blue\", \"brown\" ]\n\nsamples2 = []\n\nfor i in range(1000):\n    ball = np.random.choice(bag2)\n    samples2.append(ball)\n\ns2 = pd.Series(samples2)\n\nprint(s2.head(10))\nprint(s2.value_counts().sort_index())\n\ns2.value_counts().sort_index().plot(kind=\"bar\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0     blue\n1     blue\n2     blue\n3     blue\n4     blue\n5     blue\n6     blue\n7    brown\n8     blue\n9    brown\ndtype: object\nblue     734\nbrown    266\ndtype: int64\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](randomness_files/figure-pdf/cell-5-output-2.pdf){fig-pos='H'}\n:::\n:::\n\n\nThis is remarkable: by randomly (uniformly) drawing from the \nsecond bag, the frequencies of all samples approach the ratio of brown to blue\nballs (3:1)!\n\n## Composing random melodies\n\nSince this book is about music, let's see how we can use randomness \nto create (a resemblance of) music. For instance, we can 'compose'\na random melody by using only the white keys on a piano within some octave:\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nnotes = list(\"CDEFGAB\")\nmelody = rng.choice(notes, size=10)\nprint(melody, end=\" \")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['A' 'G' 'G' 'F' 'C' 'E' 'D' 'B' 'G' 'F'] \n```\n:::\n:::\n\n\nWe composed a little melody by randomly drawing a note from the list of notes.\nThis is also called _sampling_. Note that some notes repeat, showing that we \nsample with replacement: after each draw, the note is put back in the bag,\nso to speak. Of course, there are many things that we would have to generate, too, to make this a real melody. For instance, we do not know the duration of \nany of these notes, we don't know the meter nor the key, we don't know the\ntempo or volume, and so on. But our goal here is not to create a beautiful piece \nof music, but rather to show how we can use randomness to generate something.\n\nAs you might remember from the previous chapter, we can also write a function \nto do this, so that we can perform this operation (composition of a random \nmelody) more easily, while at the same time having more control over it \nthrough its parameters. The following function does exactly this, having \nonly one parameter that controlls the length of the melody (the number of\nnotes to be sampled).\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\ndef melody(n):\n    notes = list(\"CDEFGAB\")\n    return rng.choice(notes, size=n)\n```\n:::\n\n\nWe can now use this function to easily create random melodies of \ndifferent lengths:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nprint(melody(7))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['E' 'B' 'E' 'A' 'F' 'B' 'B']\n```\n:::\n:::\n\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nprint(melody(12))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['G' 'E' 'B' 'G' 'E' 'D' 'F' 'C' 'E' 'B' 'F' 'C']\n```\n:::\n:::\n\n\n## Synthesizing a corpus\n\nThe functionalities introduced above allow us to synthesize an artificial corpus\nof melodies, here simplified as lists of pitch classes and containing varying\nnumbers of notes.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nN = 4 # number of pieces in the corpus\ncorpus = [ melody(12) for _ in range(N)]\n```\n:::\n\n\nThe first three melodies of our corpus are:\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nfor mel in corpus:\n    print(mel)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['B' 'F' 'D' 'D' 'C' 'E' 'B' 'G' 'F' 'A' 'B' 'D']\n['B' 'G' 'F' 'A' 'F' 'E' 'B' 'B' 'A' 'E' 'B' 'D']\n['E' 'C' 'C' 'C' 'B' 'B' 'E' 'D' 'E' 'B' 'D' 'A']\n['C' 'F' 'C' 'A' 'B' 'E' 'B' 'B' 'D' 'F' 'G' 'E']\n```\n:::\n:::\n\n\nOf course, melodies are not always of the same length.\nWe could vary the lenght of the melodies by creating a hand-crafted list\nspecifying the number of notes for each melody in the corpus.\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\ncorpus = [ melody(n) for n in [10, 5, 7, 13] ]\n\nfor mel in corpus:\n    print(mel)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['A' 'C' 'A' 'G' 'D' 'A' 'C' 'D' 'G' 'C']\n['E' 'E' 'C' 'B' 'B']\n['F' 'B' 'G' 'E' 'B' 'C' 'C']\n['F' 'B' 'A' 'F' 'E' 'D' 'C' 'C' 'G' 'E' 'C' 'G' 'G']\n```\n:::\n:::\n\n\nHowever, specifying the lenghts of the melodies for a large corpus\nwould be a very time-consuming task. In order to model the \nvariability in length of melodies in a musical corpus, we will \n_randomly sample_ them from a specified probability distribution.\nA good candidate for such a distribution is the [Poisson distribution](https://en.wikipedia.org/wiki/Poisson_distribution),\nthat we can access from our random number generator `rng`.\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nlam = 25 # average number of notes in melody\nN = 1000 # number of pieces in the corpus \n\ncorpus = [ melody(rng.poisson(lam=lam)) for _ in range(N) ]\n\nlengths = pd.Series([ len(m) for m in corpus ]).value_counts()\n\nidx = range(0, max(lengths))\nlengths = lengths.sort_index().reindex(idx).fillna(0)\nplt.bar(idx, lengths)\nplt.axvline(lam, c=\"red\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Distribution of melody lengths in the corpus.\"](randomness_files/figure-pdf/fig-piece-lengths-output-1.pdf){#fig-piece-lengths fig-pos='H'}\n:::\n:::\n\n\nNow the variable `corpus` contains lists of pitch classes (_aka_ melodies)\nof different lengths, most of them around the preset average value `lam`,[^1]\nalso indicated by the vertical red line.\nIt is moreover evident that the corpus contains rather few very short or long melodies.\n\n[^1]: Short for the Greek letter $\\lambda$ (\"lambda\").\n\nWe can, of course, not only observe the distribution of melody lengths, but also \nlook at the overall distribution of note occurrence in the corpus:\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\ncounts = []\n\nfor m in corpus:\n    c = pd.Series(m)\n    counts.append(c)\n\npd.concat(counts).value_counts().plot(kind=\"bar\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Overall note frequencies in the artificial corpus.](randomness_files/figure-pdf/fig-note-freqs-output-1.pdf){#fig-note-freqs fig-pos='H'}\n:::\n:::\n\n\nAt this point, we should stop and celebrate. We have just written our first _probabilistic model_\nto generate melodies. Admittedly, it is not a very good model for actual melodies, for example\nbecause notes are drawn _uniformly at random_ from the set of diatonic pitch classes\nusing the `.choice()` method, which leads to the somewhat unrealistic picture in @fig-note-freqs.\nOne would expect that in real melodies some notes occur more often than others\nand that the occurrence of a note does, for instance, also depend on the notes that come before and after it.\nBut, in principle, these other constraints could be added to our model to make it more realistic.\nThe point here was mainly to illustrate how artificial corpora can be generated probabilistically.\nThis will prove useful later on because it allows us to compare real-world corpora of music against \nsynthetic ones generated by our models.\n\n::: {.callout-tip}\n## Exercise\n\nExpand our melody model so that it also includes octave information for each pitch class\nin order to make it a bit more musical.\n:::\n\n## Pattern search\n\n### Incipits \n\nNow that we have a corpus that we understand very well because we specified \nhow it has been created, we can apply some simple analytical questions in order \nto warm up for later. For instance, we could want to have a function that \nallows us to search for _incipits_. Incipits are the beginnings of musical melodies\nthat already to characterize themes and motives because incipits are often characteristic. \nFor example, we would want to look for all melodies that begin with \"C\", \"D\", \"E\" and, \nfor simplicity, we might want to pass a string like \"CDE\" to the function to facilitate the input.\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nimport re \n\ndef find_incipit(incip=\"\", mel=None):\n    melody = \"\".join(mel)\n    if re.search(\"^\" + incip, melody):\n        return True\n    else:\n        return False\n\nfor m in corpus[:10]:\n    if find_incipit(incip=\"CDE\", mel=m):\n        print(\"\".join(m))\n```\n:::\n\n\n### Finals\n\nWe can apply a similar logic to find finals, the \nlast notes of a melody. Instead of only allowing\nto search for a single note as a final, we will \nallow more generally to allow for a pattern that concludes\na melody:\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\ndef find_finals(end=\"\", mel=None):\n    melody = \"\".join(mel)\n    if re.search(end + \"$\", melody):\n        return True \n\nfor m in corpus[:100]:\n    if find_finals(end=\"GC\", mel=m):\n        print(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['G' 'F' 'G' 'D' 'D' 'E' 'A' 'E' 'E' 'E' 'B' 'A' 'G' 'G' 'A' 'F' 'D' 'B'\n 'E' 'G' 'E' 'F' 'B' 'D' 'D' 'E' 'E' 'G' 'C']\n```\n:::\n:::\n\n\nAs you can see, all found melodies end with a falling perfect\nfifth form \"G\" to \"C\".\n\nThe last function, `find_finals()`, \nintroduced the \"^\" (caret) character.\nIn the context of regular expressions, this character signifies \n\"at the end of a string\", exactly what we needed to find finals.\n\n### Patterns more generally\n\n::: {.callout-warning}\n## Todo\nIntroduce regexes more flexibly and write a general pattern matcher.\n:::\n\n## Random Bach \n\nFour-part writing is a core part of Western composition history.\nHere, we will build a mock version of a four-part chorale by randomly \ngenerating each voice and putting them together in a table. \nDoing so will show you how you can create tables, which we will need later on.\nThe most popular way to work with tables in Python is by using the `pandas` library. \nIn `pandas`, tables are called 'data frames', and there is a `DataFrame`\nobject to represent tables. Let's see how we could create a four-part homophonic \nchorale with eight 'chords':\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nimport pandas as pd\n\nn = 8\n\nchorale = pd.DataFrame({\n    \"S\" : melody(n),\n    \"A\" : melody(n),\n    \"T\" : melody(n),\n    \"B\" : melody(n)\n})\n```\n:::\n\n\nThe variable `chorale` now stores our little composition and we can inspect it:\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nchorale\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```{=tex}\n\\begin{tabular}{lllll}\n\\toprule\n{} &  S &  A &  T &  B \\\\\n\\midrule\n0 &  C &  A &  D &  E \\\\\n1 &  F &  C &  E &  D \\\\\n2 &  C &  A &  E &  D \\\\\n3 &  B &  G &  F &  A \\\\\n4 &  C &  B &  D &  D \\\\\n5 &  D &  D &  B &  B \\\\\n6 &  D &  C &  G &  A \\\\\n7 &  B &  G &  A &  D \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nHere we have generated each voice using the `melody` function. \nWe can use it to create a new function that will directly give us a new \nchorale of a certain length:\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\ndef chorale(n):\n    df = pd.DataFrame({\n        \"S\" : melody(n=n),\n        \"A\" : melody(n=n),\n        \"T\" : melody(n=n),\n        \"B\" : melody(n=n)\n    })\n\n    return df\n```\n:::\n\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\nmy_chorale = chorale(n=12)\nmy_chorale\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```{=tex}\n\\begin{tabular}{lllll}\n\\toprule\n{} &  S &  A &  T &  B \\\\\n\\midrule\n0  &  B &  B &  C &  F \\\\\n1  &  C &  D &  E &  D \\\\\n2  &  F &  E &  C &  A \\\\\n3  &  E &  F &  D &  B \\\\\n4  &  D &  A &  A &  B \\\\\n5  &  F &  G &  G &  B \\\\\n6  &  A &  D &  A &  B \\\\\n7  &  F &  G &  B &  D \\\\\n8  &  B &  E &  B &  F \\\\\n9  &  B &  E &  F &  G \\\\\n10 &  C &  A &  G &  B \\\\\n11 &  C &  F &  D &  D \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nIt will look a bit closer to musical notation if \nwe transpose the data frame by using the `.transpose()` method:\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nmy_chorale.transpose()\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```{=tex}\n\\begin{tabular}{lllllllllllll}\n\\toprule\n{} & 0  & 1  & 2  & 3  & 4  & 5  & 6  & 7  & 8  & 9  & 10 & 11 \\\\\n\\midrule\nS &  B &  C &  F &  E &  D &  F &  A &  F &  B &  B &  C &  C \\\\\nA &  B &  D &  E &  F &  A &  G &  D &  G &  E &  E &  A &  F \\\\\nT &  C &  E &  C &  D &  A &  G &  A &  B &  B &  F &  G &  D \\\\\nB &  F &  D &  A &  B &  B &  B &  B &  D &  F &  G &  B &  D \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n## Accessing data\n\nHaving the variable `my_chorale` store our data frame, \nthis is how we can access individual voices:\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\nmy_chorale[\"T\"]\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```{=tex}\n\\begin{tabular}{ll}\n\\toprule\n{} &  T \\\\\n\\midrule\n0  &  C \\\\\n1  &  E \\\\\n2  &  C \\\\\n3  &  D \\\\\n4  &  A \\\\\n5  &  G \\\\\n6  &  A \\\\\n7  &  B \\\\\n8  &  B \\\\\n9  &  F \\\\\n10 &  G \\\\\n11 &  D \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nYou can verify that it is the same 'melody' as above in the chorale. \nIf we want a specific note from this voice, say the fifth one, \nwe can access is this way:\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\nmy_chorale[\"T\"][4]\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\n'A'\n```\n:::\n:::\n\n\nWe first select the \"T\" column, and then select the fifth element \n(remember that we start counting at 0, so we need to insert 4 to get the \nfifth). We can also get entire ranges of a voice:\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\nmy_chorale[\"A\"][4:8]\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```{=tex}\n\\begin{tabular}{ll}\n\\toprule\n{} &  A \\\\\n\\midrule\n4 &  A \\\\\n5 &  G \\\\\n6 &  D \\\\\n7 &  G \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nThis gives us the fifths to ninth note in the Alto voice. \nIf we want to apply the same logic also to column ranges, \nwe have to write it a bit differently using the `.loc()`\nmethod for localising data:\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\nmy_chorale.loc[1:3, \"S\":\"A\"]\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```{=tex}\n\\begin{tabular}{lll}\n\\toprule\n{} &  S &  A \\\\\n\\midrule\n1 &  C &  D \\\\\n2 &  F &  E \\\\\n3 &  E &  F \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n`.loc()` takes two arguments: the rows (or row range),\nand the columns (or column range). We can use it to 'slice'\nour data frame in order to get specific portions of it.\n\n",
    "supporting": [
      "randomness_files/figure-pdf"
    ],
    "filters": []
  }
}