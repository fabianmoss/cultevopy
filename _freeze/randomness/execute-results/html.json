{
  "hash": "103d05f8030f60be78eba30f6885d806",
  "result": {
    "markdown": "# Randomness {#sec-randomness}\n\nThis course is about music and evolution,\nspecifically about using computational models\nto better understand the mechanisms underlying certain evolutionary\nprocesses. In order to do so, we will often run simulations \nto observe and interpret the resulting scenarios against the backdrop\nof our modeling assumptions and our domain knowledge.\n\nSimulations are useful because for many situations we \nare not able to provide deterministic mathematical formulae to obtain \noutcomes from inputs. Rather, we incorporate our knowledge about the world\nin a computational model and use randomness to include the inherent uncertainty\nabout the exact outcomes of the simulations.\n\nBut randomness is a difficult concept to capture. \nFor the purpose of this book, we will simulate a speficic kind of randomness\nby sampling from a certain set of items.\nLess technically, we can imagine a bag with a certain number of balls in it,\neach having a certain color (multiple balls can have the same color). \nA _random uniform sample with replacement_ then corresponds to picking a \nball from the bag without looking in it and putting it back in the bag.\n\nLet's try this in Python. We will use the `random` modul of the _NumPy_ library:\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\n\nbag = range(4)\nball = np.random.choice(bag)\n\nprint(ball)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0\n```\n:::\n:::\n\n\nIf this draw were really random, we would expect that each number is equally likely.\nWe can test this by repeating this procedure again and again, tallying the result each time.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nsamples = []\n\nfor i in range(1000):\n    ball = np.random.choice(bag)\n    samples.append(ball)\n\ns = pd.Series(samples)\n\nprint(s.head(10))\nprint(s.value_counts().sort_index())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0    0\n1    1\n2    2\n3    3\n4    3\n5    3\n6    0\n7    3\n8    2\n9    3\ndtype: int64\n0    242\n1    255\n2    254\n3    249\ndtype: int64\n```\n:::\n:::\n\n\nThe number are not exactly the same but pretty close. If we would continue sampling\nfrom our bag, they would get more and more similar to one another.\nIt is easier to understand this by visualizing it.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ns.value_counts().sort_index().plot(kind=\"bar\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](randomness_files/figure-html/cell-4-output-1.png){width=575 height=407}\n:::\n:::\n\n\nNow, what if the numbers in the bag were not just numbered,\nbut had different colors? Let's assume we have another bag, `bag2`,\nwith 4 balls, three brown, one blue:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nbag2 = [\"brown\", \"brown\", \"brown\", \"blue\"]\n\nsamples2 = []\n\nfor i in range(1000):\n    ball = np.random.choice(bag2)\n    samples2.append(ball)\n\ns2 = pd.Series(samples2)\n\nprint(s2.head(10))\nprint(s2.value_counts().sort_index())\n\ns2.value_counts().sort_index().plot(kind=\"bar\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0    brown\n1    brown\n2     blue\n3     blue\n4    brown\n5    brown\n6    brown\n7    brown\n8    brown\n9    brown\ndtype: object\nblue     232\nbrown    768\ndtype: int64\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](randomness_files/figure-html/cell-5-output-2.png){width=575 height=441}\n:::\n:::\n\n\nThis is remarkable: by randomly (uniformly) drawing from the \nsecond bag, the frequencies of all samples approach the ratio of brown to blue\nballs (~3:1)!\n\n",
    "supporting": [
      "randomness_files"
    ],
    "filters": [],
    "includes": {}
  }
}