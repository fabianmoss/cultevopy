{
  "hash": "340236478bfe0ef9d129835229d20b1a",
  "result": {
    "engine": "jupyter",
    "markdown": "---\nsubtitle: ''\n---\n\n# Biased transmission: frequency-dependent indirect bias {#sec-frequency-biased-transmission}\n\n:::{.callout-note}\nThis chapter is based on \"Chapter 4: Biased transmission: frequency-dependent indirect bias\" in @Acerbi2022.\n:::\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np \nrng = np.random.default_rng()\n\nimport pandas as pd\n```\n:::\n\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\ndef plot_multiple_runs(data_model):\n    groups = data_model.groupby(\"run\")\n    for _, g in groups:\n        g.index = g[\"generation\"]\n        g[\"p\"].plot(lw=.5, ylim=(0,1))\n\n    data_model.groupby(\"generation\")[\"p\"].mean().plot(c=\"k\", lw=\"1\")\n```\n:::\n\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nN = 100\np_0 = .5\nD = 1.\n```\n:::\n\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n# Create first generation\npopulation = pd.DataFrame({\"trait\": rng.choice([\"A\", \"B\"], size=N, replace=True, p=[p_0, 1-p_0])})\n```\n:::\n\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n# Create a DataFrame with a set of 3 randomly-picked demonstrators for each agent\n\ndemonstrators = pd.DataFrame({\n    \"dem1\" : population[\"trait\"].sample(N, replace=True).values,\n    \"dem2\" : population[\"trait\"].sample(N, replace=True).values,\n    \"dem3\" : population[\"trait\"].sample(N, replace=True).values\n})\n```\n:::\n\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\n# Visualize the DataFrame\ndemonstrators.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```{=tex}\n\\begin{tabular}{llll}\n\\toprule\n{} & dem1 & dem2 & dem3 \\\\\n\\midrule\n0 &    B &    A &    A \\\\\n1 &    B &    B &    A \\\\\n2 &    B &    A &    B \\\\\n3 &    A &    A &    A \\\\\n4 &    A &    B &    A \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n# Get the number of A's in each 3-demonstrator combination\nnum_As = (demonstrators == \"A\").apply(sum, axis=1)\nnum_As.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```{=tex}\n\\begin{tabular}{lr}\n\\toprule\n{} &  0 \\\\\n\\midrule\n0 &  2 \\\\\n1 &  1 \\\\\n2 &  1 \\\\\n3 &  3 \\\\\n4 &  2 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\n# For 3-demonstrator combinations with all A's, set to A\npopulation[ num_As == 3 ] = \"A\"\n# For 3-demonstrator combinations with all B's, set to B\npopulation[ num_As == 0 ] = \"B\"\n```\n:::\n\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nprob_majority = rng.choice([True, False], p=[(2/3 + D/3), 1-(2/3 + D/3)], size=N, replace=True)\nprob_minority = rng.choice([True, False], p=[(1/3 + D/3), 1-(1/3 + D/3)], size=N, replace=True)\n```\n:::\n\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\n# 3-demonstrator combinations with two As and one B\ncondition = prob_majority & (num_As == 2)\nif condition.sum() > 0:\n    population.loc[condition, \"trait\"] = \"A\"\ncondition = ~prob_majority & (num_As == 2)\nif condition.sum() > 0:\n    population.loc[condition, \"trait\"] = \"B\"\n\n# 3-demonstrator combinations with two B's and one A\ncondition = ~prob_minority & (num_As == 1)\nif condition.sum() > 0:\n    population.loc[condition, \"trait\"] = \"A\"\ncondition = prob_minority & (num_As == 1)\nif condition.sum() > 0:\n    population.loc[condition, \"trait\"] = \"B\"\n```\n:::\n\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\ndemonstrators[\"new_trait\"] = population[\"trait\"]\ndemonstrators.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```{=tex}\n\\begin{tabular}{lllll}\n\\toprule\n{} & dem1 & dem2 & dem3 & new\\_trait \\\\\n\\midrule\n0 &    B &    A &    A &         A \\\\\n1 &    B &    B &    A &         B \\\\\n2 &    B &    A &    B &         B \\\\\n3 &    A &    A &    A &         A \\\\\n4 &    A &    B &    A &         A \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\ndef conformist_transmission(N, p_0, D, t_max, r_max):\n    # Create the output DataFrame\n    output = pd.DataFrame({\n        \"generation\" : np.tile(np.arange(t_max), r_max),\n        \"p\" : [ np.nan ] * t_max * r_max,\n        \"run\" : np.repeat(np.arange(r_max), t_max)\n    })\n\n    for r in range(r_max):\n        # Create first generation\n        population = pd.DataFrame({\"trait\": rng.choice([\"A\", \"B\"], size=N, replace=True, p=[p_0, 1 - p_0])})\n\n        # Add first generation's p for run r\n        output.loc[ r * t_max, \"p\"] = population[ population[\"trait\"] == \"A\" ].shape[0] / N\n\n        # For each generation \n        for t in range(1,t_max):\n            demonstrators = pd.DataFrame({\n                \"dem1\" : population[\"trait\"].sample(N, replace=True).values,\n                \"dem2\" : population[\"trait\"].sample(N, replace=True).values,\n                \"dem3\" : population[\"trait\"].sample(N, replace=True).values\n            })\n\n            # Get the number of A's in each 3-demonstrator combination\n            num_As = (demonstrators == \"A\").apply(sum, axis=1)\n\n            # For 3-demonstrator combinations with all A's, set to A\n            population[ num_As == 3 ] = \"A\"\n            # For 3-demonstrator combinations with all A's, set to A\n            population[ num_As == 3 ] = \"A\"\n            # For 3-demonstrator combinations with all B's, set to B\n            population[ num_As == 0 ] = \"B\"\n\n            prob_majority = rng.choice([True, False], p=[(2/3 + D/3), 1-(2/3 + D/3)], size=N, replace=True)\n            prob_minority = rng.choice([True, False], p=[(1/3 + D/3), 1-(1/3 + D/3)], size=N, replace=True)\n\n            # 3-demonstrator combinations with two As and one B\n            condition = prob_majority & (num_As == 2)\n            if condition.sum() > 0:\n                population.loc[condition, \"trait\"] = \"A\"\n            condition = ~prob_majority & (num_As == 2)\n            if condition.sum() > 0:\n                population.loc[condition, \"trait\"] = \"B\"\n\n            # 3-demonstrator combinations with two B's and one A\n            condition = prob_minority & (num_As == 1)\n            if condition.sum() > 0:\n                population.loc[condition, \"trait\"] = \"A\"\n            condition = ~prob_minority & (num_As == 1)\n            if condition.sum() > 0:\n                population.loc[condition, \"trait\"] = \"B\"\n            \n            # Get p and put it into output slot for this generation t and run r\n            output.loc[r * t_max + t, \"p\"] = population[ population[\"trait\"] == \"A\" ].shape[0] / N\n\n    return output\n```\n:::\n\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\ndata_model = conformist_transmission(N=1_000, p_0 = 0.5, D = 1, t_max = 50, r_max = 10)\nplot_multiple_runs(data_model)\n```\n\n::: {.cell-output .cell-output-display}\n![](chapter06_files/figure-pdf/cell-14-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n",
    "supporting": [
      "chapter06_files/figure-pdf"
    ],
    "filters": []
  }
}