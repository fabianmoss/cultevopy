{
  "hash": "0666c64235fc9c46ca2df73b3cc26716",
  "result": {
    "engine": "jupyter",
    "markdown": "# Unbiased mutation {#sec-unbiased_biased_mutation}\n\n:::{.callout-note}\nThis chapter is based on \"Chapter 2: Unbiased and biased mutation\" in @Acerbi2022.\n:::\n\n::: {#d8b88c45 .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nrng = np.random.default_rng()\n\nimport pandas as pd\n```\n:::\n\n\n::: {#4e3cafe4 .cell execution_count=2}\n``` {.python .cell-code}\ndef unbiased_mutation(N, mu, p_0, t_max, r_max):\n    # Create an output DataFrame\n    output = pd.DataFrame({\n        \"generation\" : np.tile(np.arange(t_max), r_max),\n        \"p\" : [ np.nan ] * t_max * r_max,\n        \"run\" : np.repeat(np.arange(r_max), t_max)\n    })\n\n    for r in range(r_max):\n        # Create first generation\n        population = pd.DataFrame({\"trait\": rng.choice([\"A\", \"B\"], size=N, replace=True, p=[p_0, 1 - p_0])})\n\n        # Add first generation's p for run r\n        output.loc[ r * t_max, \"p\"] = population[ population[\"trait\"] == \"A\" ].shape[0] / N\n\n        # For each generation \n        for t in range(1,t_max):\n            # Copy individuals to previous_population DataFrame\n            previous_population = population.copy()\n            \n            # Determine \"mutant\" individuals\n            mutate = rng.choice([True, False], size=N, p=[mu, 1-mu], replace=True)\n\n            # TODO: Something is off here! Changing the order of the conditions affects\n            # the result. Should be constant with random noise but converges to either A or B\n\n            # If there are \"mutants\" from A to B \n            conditionA = mutate & (previous_population[\"trait\"] == \"A\")\n            if conditionA.sum() > 0:\n                population.loc[conditionA, \"trait\"] = \"B\"\n\n            # If there are \"mutants\" from B to A\n            conditionB = mutate & (previous_population[\"trait\"] == \"B\")\n            if conditionB.sum() > 0:\n                population.loc[conditionB, \"trait\"] = \"A\"\n\n            # Get p and put it into output slot for this generation t and run r\n            output.loc[r * t_max + t, \"p\"] = population[ population[\"trait\"] == \"A\" ].shape[0] / N\n\n    return output \n```\n:::\n\n\n::: {#132b1f1f .cell execution_count=3}\n``` {.python .cell-code}\ndef plot_multiple_runs(data_model):\n    groups = data_model.groupby(\"run\")\n    for _, g in groups:\n        g.index = g[\"generation\"]\n        g[\"p\"].plot(lw=.5, ylim=(0,1))\n\n    data_model.groupby(\"generation\")[\"p\"].mean().plot(c=\"k\", lw=\"1\")\n```\n:::\n\n\n::: {#bd227a8a .cell execution_count=4}\n``` {.python .cell-code}\ndata_model = unbiased_mutation(N=100, mu=.05, p_0=0.5, t_max=200, r_max=5)\nplot_multiple_runs(data_model)\n```\n\n::: {.cell-output .cell-output-display}\n![](chapter04_files/figure-html/cell-5-output-1.png){}\n:::\n:::\n\n\n::: {#12f8ac00 .cell execution_count=5}\n``` {.python .cell-code}\ndata_model = unbiased_mutation(N=100, mu=.05, p_0=0.1, t_max=200, r_max=5)\nplot_multiple_runs(data_model)\n```\n\n::: {.cell-output .cell-output-display}\n![](chapter04_files/figure-html/cell-6-output-1.png){}\n:::\n:::\n\n\n",
    "supporting": [
      "chapter04_files"
    ],
    "filters": [],
    "includes": {}
  }
}