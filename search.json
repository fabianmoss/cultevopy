[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Cultural Evolution and Music",
    "section": "",
    "text": "On these pages you will learn about cultural evolution and music. The overall aim is to attain a basic understanding of formal models in cultural evolution and learn about several recent approaches that apply them to the domain of music.\nWe start with a minimal introduction to the Python programming language that covers the necessary basic skills in order to follow the remainder of the book. Then, we summarize some general ideas about music and cultural evolution.\nSubsequently, we follow the excellent learning path for computational models in cultural evolution provided by the book Individual-based models of cultural evolution: A step-by-step guide using R (Acerbi et al., 2022). These pages comprise a translation of this resource to Python. Finally, we will review and discuss a number of recent publications on music and cultural evolution in the advanced topics section at the end.\n\n\n\n\n\n\nIf you want to refer to this resource, please cite it as appropriately, e.g.: Moss, F. C. (2022). “Cultural Evolution and Music: Models and Applications in Python”. https://fabianmoss.github.io/cultevopy\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nThe material on this page has been adapted and designed for a research seminar in musicology at Würzburg University, Germany.\nNote that the materials here are still under development. Please inform me if you notice any errors or other issues.\n\n\n\n\nI am grateful for encouragement from Alberto Acerbi to continue working on my Python translation of his book and many helpful comments.\n\n\n\n\nAcerbi, A., Mesoudi, A., & Smolla, M. (2022). Individual-based models of cultural evolution: A step-by-step guide using R. Routledge. https://acerbialberto.com/IBM-cultevo/"
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "The field of cultural evolution emerged in the 1980’s (e.g., Boyd & Richerson, 1985; Cavalli-Sforza & Feldman, 1981), and has, in parallel with the advancement of computational facilities, gained momentum. Theories on cultural evolution share many facets with approaches on memetics (Aunger, 2001; Blackmore, 2000; Dawkins, 1976), a field that has also been applied to the case of music (Jan, 2016).\nIn recent years, several approaches have attempted to apply formal models from cultural evolution to the domain of music.\nIn the present context, we first introduce some central ideas of cultural evolution and review a few major publications for the domain of music.\nA few selected important contributions are:\n\n“Cultural Transmission and Evolution: A Quantitative Approach” (Cavalli-Sforza & Feldman, 1981)\n“Culture and the Evolutionary Process” (Boyd & Richerson, 1985)\n“The Memetics of Music” (Jan, 2016)\n“Cultural Evolution and Music” (Youngblood et al., forthcoming)\n“Cultural Evolution of Music” (Savage, 2019)"
  },
  {
    "objectID": "intro.html#music-in-human-evolution",
    "href": "intro.html#music-in-human-evolution",
    "title": "1  Introduction",
    "section": "1.2 Music in human evolution",
    "text": "1.2 Music in human evolution\nThis book is about the cultural evolution of music. It has to be mentioned, however, that there is a large body of research on the biological evolution of music. This research asks questions about with which evolutionary advantages music endowed early humans, whether it is something that we share with other animals or whether it makes us unique. Some hold the view that music has no particularly relevant evolutionary function at all (Pinker, 1997), while others see in it a key to our success as a species (Cross, 2016).\nWhatever the true role of music in the evolutionary history of humanity may have been, it is most certainly a fascinating topic to reflect upon. After all, human musical activity with dedicated instruments can be traced back at least 20,000 years, although it seems more than likely that human ‘musicking’ dates back much further, since our own bodies and voices already provided us with excellent musical instruments long before the first instruments have been devised.\nIf you are interested in learning more about biological-evolutionary aspects of music, I highly recommend to read, e.g. Wallin et al. (2001), Morley (2013), Tomlinson (2018), and Honing (2018)."
  },
  {
    "objectID": "intro.html#music-history-and-cultural-evolution",
    "href": "intro.html#music-history-and-cultural-evolution",
    "title": "1  Introduction",
    "section": "1.3 Music history and cultural evolution",
    "text": "1.3 Music history and cultural evolution\nDocumenting, describing, and interpreting changes in human culture is what historians do. Accordingly, changes in music belong to the field of music history, or historical musicology. However, most historians would probably be hesitant to employ models, or worse: formal models, in order to describe historical processes. The dictum “history doesn’t repeat itself” seems to raise a fundamental argument against such endeavors that aim at explaining cultural or historical changes by means of underlying latent ‘forces’. Modeling, in that view, seems to erroneously assume that history is teleological – directed towards a predetermined goal.\nOn the other hand, it is undeniable that there are many aspects of culture exhibit regularities and ‘progresses’ that are hard to explain if there are no guiding processes. Defining “culture” is, of course, yet another difficult enterprise. Here, I follow more or less the definition of Boyd & Richerson (1985, p. 33): “Culture is information capable of affecting individuals’ phenotypes which they acquire from other conspecifics by teaching or imitation [emphasis mine]”.1 The part important to us here is “by teaching or imitation”, which is meant to imply: not by genetic inheritance. If humans can transmit information by other means than genetic inheritance, and if these transmission processes continue over many generations, then they are worth studying. Rest assured, the assumption of a hidden goal towards which all cultural processes are directed is not needed at all! I hope that you will share this conviction after working through this material."
  },
  {
    "objectID": "intro.html#central-ideas-and-overview",
    "href": "intro.html#central-ideas-and-overview",
    "title": "1  Introduction",
    "section": "1.4 Central ideas and overview",
    "text": "1.4 Central ideas and overview\nFollowing this introduction, we introduce some minimal requirements to use Python for this course (Chapter 2).\nSubsequently, we introduce with six central mechanisms for cultural inheritance: unbiased transmission (Chapter 3), unbiased and biased mutation (Chapter 4), directly biased transmission (Chapter 5), frequency-dependent indirectly biased transmission (Chapter 6), and demonstrator-based indirectly biased transmission (Chapter 7). We follow up with a chapter on vertical and horizontal transmission (Section 8.1), and finally introduce the multiple traits model (Chapter 9). The following diagram gives an overview of these processes:\n\n\n\n\nflowchart TD\n  C[Cultural inheritance \\n mechanisms] --> T(Transmission)\n  C --> M(Mutation)\n  T --> BT(Biased)\n  T --> UT(Unbiased)\n  M --> BM(Biased)\n  M --> UM(Unbiased)\n  BT --> D(Direct)\n  BT --> I(Indirect)\n  I --> FD(Frequency-Dependent)\n  I --> DB(Demonstrator-Based)\n\n\n\n\n\n\n\n\nAfter having a firm grasp on how these processes can be modeled in Python and how modeling results can be interpreted, we move to more advanced topics (Chapter 10), and more specifically into a number of recent exciting results about cultural evolution and music. We conclude our journey (Chapter 11) with a more general discussion of the implications of cultural evolution for how we think about music, on the relevance of modeling in music research and the humanities more generally, as well as on the great potential of this approach for future research.\n\n\n\n\nAunger, R. (2001). Darwinizing Culture: The Status of Memetics as a Science. Oxford University Press, USA. http://gen.lib.rus.ec/book/index.php?md5=7329e2aa9adcddfed967088219426193\n\n\nBlackmore, S. (2000). The Meme Machine. Oxford University Press.\n\n\nBoyd, R., & Richerson, P. J. (1985). Culture and the Evolutionary Process. The University of Chicago Press.\n\n\nCavalli-Sforza, L. L., & Feldman, M. W. (1981). Cultural Transmission and Evolution. Princeton University Press.\n\n\nCross, I. (2016). The nature of music and its evolution. In S. Hallam, I. Cross, & M. Thaut (Eds.), The Oxford Handbook of Music Psychology (2nd ed., pp. 1–20). Oxford University Press. https://doi.org/10.1093/oxfordhb/9780199298457.013.0001\n\n\nDawkins, R. (1976). The Selfish Gene. Oxford University Press.\n\n\nHoning, H. (2018). On the biological basis of musicality. Annals of the New York Academy of Sciences. https://doi.org/10.1111/nyas.13638\n\n\nJan, S. (2016). The Memetics of Music: A Neo-Darwinian View of Musical Structure and Culture. Routledge.\n\n\nMorley, I. (2013). The Prehistory of Music. Human Evolution, Archaeology, and the Origins of Musicality. Oxford University Press.\n\n\nPinker, S. (1997). How the mind works. Norton.\n\n\nSavage, P. E. (2019). Cultural evolution of music. Palgrave Communications, 5(1), 1–16. https://doi.org/10.1057/s41599-019-0221-1\n\n\nTomlinson, G. (2018). A Million Years of Music. Princeton University Press. https://press.princeton.edu/books/paperback/9781890951528/a-million-years-of-music\n\n\nWallin, N. L., Merker, B., & Brown, S. (Eds.). (2001). The Origins of Music. MIT Press.\n\n\nYoungblood, M., Ozaki, Y., & Savage, P. E. (forthcoming). Cultural evolution and music. In J. Tehrani, J. R. Kendal, & R. L. Kendal (Eds.), Oxford Handbook of Cultural Evolution. Oxford University Press. https://psyarxiv.com/xsb7v"
  },
  {
    "objectID": "python_primer.html",
    "href": "python_primer.html",
    "title": "2  A Python primer",
    "section": "",
    "text": "Note\n\n\n\nFrom now on, we will assume that you have a working Python installation running on your computer. You can check this by typing the following into a terminal/console/command line:\npython --version\nIf the version number starts with a 3, you’re all set. If not, please consider one of the many tutorials online on how to install Python."
  },
  {
    "objectID": "python_primer.html#variables-and-types",
    "href": "python_primer.html#variables-and-types",
    "title": "2  A Python primer",
    "section": "2.1 Variables and types",
    "text": "2.1 Variables and types\nVariable assignment in Python is straight-forward. You choose a name for the variable, and assign a value to it using the = operator, for example:\n\nx = 100\n\nassigns the value 100 to the variable x. If we call the variable now, we can see that it has the value we assigned to it:\n\nx\n\n100\n\n\nOf course, we can also assign things other than numbers, for example:\n\nname = \"Fabian\"\n\nWhat we assigned to the variable name is called a string, it has the value \"Fabian\". Strings are sequences of characters.\n\n\n\n\n\n\nTip\n\n\n\nNote that \"Fabian\" is enclosed by double-quotes. Why is this the case? Why could we not just type name = Fabian?\n\n\nWe can also assign a list of things to a variable:\n\nmylist = [1, 2, 3, \"A\", \"B\", \"C\"]\n\nLists are enclosed by square brackets. As you can see, Python allows you to store any kind of data in lists (here: integer numbers and character strings). However, it is good practice to include only—you’ll understand later why.\nAnother structured data type in python are dictionaries. Dictionaries are collections of key-value pairs. For example, a dictionary addresses could store the email addresses of certain people:\n\naddresses = {\n    \"Andrew\" : \"andrew@example.com\",\n    \"Zoe\" : \"zoe@example.com\"\n}\n\nNow, if we wanted to look up Zoe’s email address, we could to so with:\n\naddresses[\"Zoe\"]\n\n'zoe@example.com'"
  },
  {
    "objectID": "python_primer.html#on-repeat",
    "href": "python_primer.html#on-repeat",
    "title": "2  A Python primer",
    "section": "2.2 On repeat",
    "text": "2.2 On repeat\nCoding something is only useful if you can’t do the job as fast or as efficient by yourself. Especially when it comes to repeating the same little thing many, many times, knowing how to code comes in handy.\nAs a simple example, imagine you want to write down all numbers from 1 to 10, or from 1 to 100, or… you get the idea. In Python, you would do it as follows:\n\nfor i in range(10):\n    print(i)\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nYou see that this is not exactly what we wanted. We’re seeing numbers from 0 to 9, but we wanted everything from 1 to 10. Before we fix the code to produce the desired result, let’s explain the bits and pieces of the code above. What we just did was to use a so-called for-loop, probably the most common way to repeat things in Python. First we create an iterator variable i (we could have named any other variable name as well), which takes its value from the list of numbers specified by range(10). If only one number n is provided to range(n), it will enumerate all numbers from 0 to n-1. If two arguments are provided, the first one determines the starting number, and the second one stands for the terminating number minus one—confusing, right? So, in order to enumerate all numbers from 1 to 10, we have to write range(1,11). Finally, the print function outputs the value of i for each iteration.\n\nfor i in range(1,11):\n    print(i)\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nVoilà!"
  },
  {
    "objectID": "python_primer.html#functions",
    "href": "python_primer.html#functions",
    "title": "2  A Python primer",
    "section": "2.3 Functions",
    "text": "2.3 Functions\nWith more and more experience in programming, it is likely that your code will become more and more complex. That means that it will become harder to keep track of what every piece of it is supposed to do. A good strategy to deal with this is to aim for writing code that is modular: it can be broken down into smaller units (modules) that are easier to understand. Moreover, it is sometimes necessary to reuse the same code several times. It would, however, be inefficient to write the same lines over and over again. With your code being modular you can wrap the pieces that you need in several places into a function.\nLet’s look at an example! Assume, your (fairly) complex code involves calculating the sum of the products of two numbers. In Python, we use the + operator to calculate sums and the ** operator to raise a number to a certain power (**2 for the square of a number).\n\nx = 3\ny = 5\n\nsum_of_squares = x**2 + y**2\n\nThe variable sum_of_squares now contains the sum of squares of x=3 and y=5. We can inspect the result by calling the variable:\n\nsum_of_squares \n\n34\n\n\nNow, imagine that you would have to do the same calculation several times for different combinations of values for x and y (and always keeping in mind that this stands in for much more complex examples with several lines of code). We can this code in a function:\n\ndef func_sum_of_squares(x, y):\n    return x**2 + y**2\n\nNow, each time we want to calculate a sum of squares, we can do so by simply invoking\n\nfunc_sum_of_squares(5,4)\n\n41\n\n\nAnd, of course, we could chose a shorter name for the function as well:\n\nf = func_sum_of_squares\n\nf(5,4)\n\n41"
  },
  {
    "objectID": "python_primer.html#libraries-youll-love",
    "href": "python_primer.html#libraries-youll-love",
    "title": "2  A Python primer",
    "section": "2.4 Libraries you’ll love",
    "text": "2.4 Libraries you’ll love\nLuckily, you don’t have to programm all functions by yourself. There is a huge community of Python programmers out there that works and collaborates on several libraries. A library is (more or less) simply a collection of certain functions (and some more, but we don’t get into this here). This means, instead of writing a function yourself, you can rely on functions that someone else has programmed.\n\n\n\n\n\n\nDanger\n\n\n\nWhether a Python library or function does actually do what it promises is another story. Popular libraries with tens of thousands of users are very trust-worthy because you can be almost sure that someone would have noticed erroneous behavior. But it is certainly possible that badly-maintained libraries contain errors. So be prudent when using the code of others.\n\n\nOne of the most popular Python libaries is NumPy for numerical computations. We will rely a lot on the functions in this library, especially in order to draw random samples—more on this later! To use the functions or variables from this library, they have to be imported so that you can use them. There are several ways to do this. For example, you can import the libary entirely:\n\nimport numpy\n\nNow, you can use the (approximated) value of \\(\\pi\\) stored in this library by typing\n\nnumpy.pi\n\n3.141592653589793\n\n\nA different way is to just import everything from the library by writing\n\nfrom numpy import * \n\nHere, the * stands for ‘everything’. Now, to use the value of \\(\\pi\\) we could simply type\n\npi\n\n3.141592653589793\n\n\nThis is, however discouraged for the following reason: imagine we had another library, numpy2 that also stores the value of \\(\\pi\\), but less precisely (e.g. only as 3.14). If we write\n\nfrom numpy import * \nfrom numpy2 import * \n\nWe would have imported the variables holding the value of \\(\\pi\\) from both libraries. But, because they have the same name pi. In this case, pi would equal 3.14 because we imported numpy2 last. This is confusing and shouldn’t be so! To avoid this, it is better to keep references to imported libraries explicit. In order not to have to type too much (we’re all lazy, after all), we can define an alias for the library.\n\nimport numpy as np\nnp.pi\n\n3.141592653589793\n\n\nAll functions of NumPy are now accessible with the prefix np.. You can choose any alias when importing a library (it can even by longer than the library name) but certain conventions have emerged that you’re encouraged to follow. Importing the most commonly used Python libraries for data-science tasks (“The data science triad”), use the following:\n\nimport numpy as np # for numerical computations\nimport pandas as pd # for tabular data \nimport matplotlib.pyplot as plt # for data visualization\n\nWe will use all three of them in the following chapters and you’ll learn to love them."
  },
  {
    "objectID": "chapter03.html",
    "href": "chapter03.html",
    "title": "3  Unbiased transmission",
    "section": "",
    "text": "Note\n\n\n\nThis chapter is based on “Chapter 1: Unbiased transmission” in Acerbi et al. (2022).\nIn this chapter, we introduce the most basic model for cultural inheritance: unbiased transmission. This process quite literally corresponds to randomly copying traits from previous generations, without any further distinctions and constraints. While this is obviously a too reductive model for how cultural transmission works, it is ideally suited to get us started with the enterprise of modeling evolutionary processes involving random variation.\nFirst we import some modules.\nBecause we will model evolutionary processes that are not strictly deterministic, we need to simulate variations due to random change. For this, we can use the default random number generator from the NumPy library and store it in the variable rng.\nNext, we define some basic variables that we take into account for our first model. We consider a population of \\(N=100\\) individuals as well as a time-frame of \\(t_{max}=100\\) generations."
  },
  {
    "objectID": "chapter03.html#simulating-a-population",
    "href": "chapter03.html#simulating-a-population",
    "title": "3  Unbiased transmission",
    "section": "3.1 Simulating a population",
    "text": "3.1 Simulating a population\n\nN = 100\nt_max = 100\n\n\n\n\n\n\n\nNote\n\n\n\nIn general, we use the variable t to designate generation counts.\n\n\nNow we create a variable population that will store the data about our simulated population. This population has either of two traits \"A\" and \"B\", with a certain probability. We store all of this in a so-called ‘data frame’, which is a somewhat fancy, Pandas-specific term for a table.\n\npopulation = pd.DataFrame(\n    {\"trait\": rng.choice([\"A\", \"B\"], size=N, replace=True)}\n)\n\nLet’s take this code apart to understand it better. From the Pandas library, which we imported as the alias pd, we create a DataFrame object. The data contained in this the data frame population is specified via a dictionary that has \"trait\" as its key and a fairly complex expression starting with the random number generator rng as its value. What this value says is, from the list [\"A\", \"B\"] choose randomly N instances with replacement (if replace were set to False, we could at most sample 2 values from the list). So, the data frame population should contain 100 randomly sampled values of A’s and B’s. Let’s confirm this:\n\npopulation.head()\n\n\n\n\n\n  \n    \n      \n      trait\n    \n  \n  \n    \n      0\n      A\n    \n    \n      1\n      B\n    \n    \n      2\n      B\n    \n    \n      3\n      B\n    \n    \n      4\n      B\n    \n  \n\n\n\n\nAs you can see, population stores a table (many of the 100 rows are omitted here for display reasons) and a single column called ‘trait’. The .head() method appended to the population data frame shows restricts the output to only the first 5 rows (0 through 4). Each row in the ‘trait’ column contains either the value A or B. To the left of the data frame you can see the numbers of rows explicitly spelled out. This is called the data frame’s index.\n\n\n\n\n\n\nNote\n\n\n\nA and B are just placeholder names for any of two mutually exclusive cultural traits. These could be, for example, preference for red over white whine (ignoring people who like rosé as well as people who have no preference). You see already here that this is a massive oversimplification of actual taste preferences. The point here is not to construct a plausible model but rather to gradually build up a simple one in order to understand well its inner workings.\nIt will help to pause for a moment and to think of other examples that “A” and “B” could stand for. Can you come up with a music-related one?\n\n\nWe can count the number of A’s and B’s as follows:\n\npopulation[\"trait\"].value_counts()\n\nB    52\nA    48\nName: trait, dtype: int64\n\n\nYou can read the above code as “From the population table, select the ‘trait’ colum and count its values.”. Since there were only two values to sample from and they were randomly (uniformly) sampled, the number of A’s and the number of B’s should be approximately equal. We can obtain their relative frequencies by adding setting the normalize keyword to True:\n\npopulation[\"trait\"].value_counts(normalize=True)\n\nB    0.52\nA    0.48\nName: trait, dtype: float64"
  },
  {
    "objectID": "chapter03.html#tracing-cultural-change",
    "href": "chapter03.html#tracing-cultural-change",
    "title": "3  Unbiased transmission",
    "section": "3.2 Tracing cultural change",
    "text": "3.2 Tracing cultural change\nWe now create a second data frame output in which we will store the output of our model. This data frame has two columns: generation, which is the number of the simulated generation, and p which stands for “the probability of an individual of having trait A”.\n\noutput = pd.DataFrame(\n    {\n        \"generation\": np.arange(t_max, dtype=int), \n        \"p\": [np.nan] * t_max \n    }\n)\n\nThe generation column contains all numbers from 0 to t_max - 1. Because we count the numbers of generations (rather than assuming a time-continuous process), we specified that numbers in this column have to be intergers (dtype=int). The values for the p column must look cryptic. It literally says: put the np.nan value t_max times into the p colum. np.nan stands for “not a number” (from the NumPy library), since we haven’t assigned any values to this probability yet.\n\noutput.head()\n\n\n\n\n\n  \n    \n      \n      generation\n      p\n    \n  \n  \n    \n      0\n      0\n      NaN\n    \n    \n      1\n      1\n      NaN\n    \n    \n      2\n      2\n      NaN\n    \n    \n      3\n      3\n      NaN\n    \n    \n      4\n      4\n      NaN\n    \n  \n\n\n\n\nDon’t worry that both the index and the ‘generation’ column contain all numbers from 0 to 99. We need this later when things become more involved.\nAs the saying goes, from nothing comes nothing, so we have to start somewhere, meaning that we need to assume that the initial probability of having trait A in our population is an actual number. The most sensible thing is to start with the proportions of A and B in our sampled population as a starting value.\nSo, we approximate the probability of an individual having trait A with the relative frequency of trait A in the population:\n\npopulation[\"trait\"].value_counts(normalize=True)[\"A\"]\n\n0.48\n\n\nYou already know this code from above, we just added the [\"A\"] part at the end to select only the relative frequencies of trait A. We want to set this as the value of p of the first generation. This can be achieved with the .loc (location) method:\n\noutput.loc[0, \"p\"] = population[\"trait\"].value_counts(normalize=True)[\"A\"]\n\nIn words, this reads: “Set location 0 (first row) in the p column of the output data frame to the relative frequency of the trait ‘A’ in the population.”"
  },
  {
    "objectID": "chapter03.html#iterating-over-generations",
    "href": "chapter03.html#iterating-over-generations",
    "title": "3  Unbiased transmission",
    "section": "3.3 Iterating over generations",
    "text": "3.3 Iterating over generations\nRecall that we are trying to observe cultural change over the course of t_max = 100 generations. We thus simply repeat what we just did for the first generation: based on the relative frequencies of A’s and B’s in the previous generation, we sample the traits of 100 new individuals for the next generation.\n\nfor t in range(1, t_max):\n    # Copy the population data frame to `previous_population`\n    previous_population = population.copy()\n  \n    # Randomly copy from previous generation's individuals\n    new_population = previous_population[\"trait\"].sample(N, replace=True).to_frame()\n    \n    # Get p and put it into the output slot for this generation t\n    output.loc[t, \"p\"] = new_population[ new_population[\"trait\"] == \"A\"].shape[0] / N\n\nThis procedure assignes a probability of having trait “A” for each generation (each row of the p colum is filled now):\n\noutput.head()\n\n\n\n\n\n  \n    \n      \n      generation\n      p\n    \n  \n  \n    \n      0\n      0\n      0.48\n    \n    \n      1\n      1\n      0.57\n    \n    \n      2\n      2\n      0.48\n    \n    \n      3\n      3\n      0.43\n    \n    \n      4\n      4\n      0.44\n    \n  \n\n\n\n\nTo make things easier, we wrap the above code in a function that we’ll call unbiased_transmission that can take different values for the population size N and number of generations t_max as parameters. The code below is exactly the same as above.\n\ndef unbiased_transmission_1(N, t_max):\n    population = pd.DataFrame({\"trait\": rng.choice([\"A\", \"B\"], size=N, replace=True)})\n\n    output = pd.DataFrame({\"generation\": np.arange(t_max, dtype=int), \"p\": [np.nan] * t_max })\n\n    output.loc[0, \"p\"] = population[ population[\"trait\"] == \"A\"].shape[0] / N\n\n    for t in range(1, t_max):\n        # Copy the population tibble to previous_population tibble\n        previous_population = population.copy()\n    \n        # Randomly copy from previous generation's individuals\n        new_population = previous_population[\"trait\"].sample(N, replace=True).to_frame()\n        \n        # Get p and put it into the output slot for this generation t\n        output.loc[t, \"p\"] = new_population[ new_population[\"trait\"] == \"A\"].shape[0] / N\n    \n    return output\n\n\ndata_model = unbiased_transmission_1(N=100, t_max=200)\n\n\ndef plot_single_run(data_model):\n    data_model[\"p\"].plot(ylim=(0,1))\n\n\nplot_single_run(data_model)\n\n\n\n\nSingle run of the unbiased transmission model for a population of \\(N=100\\) individuals and \\(t_{max}=200\\) generations.\n\n\n\n\n\ndata_model = unbiased_transmission_1(N=10_000, t_max=200)\n\n\nplot_single_run(data_model)\n\n\n\n\nSingle run of the unbiased transmission model for a population of \\(N=10,000\\) individuals and \\(t_{max}=200\\) generations.\n\n\n\n\n\ndef unbiased_transmission_2(N, t_max, r_max):\n    output = pd.DataFrame({\n        \"generation\" : np.tile(np.arange(t_max), r_max),\n        \"p\" : [ np.nan ] * t_max * r_max,\n        \"run\" : np.repeat(np.arange(r_max), t_max)\n    })\n\n    for r in range(r_max):\n        # Create first generation\n        population = pd.DataFrame({\"trait\": rng.choice([\"A\", \"B\"], size=N, replace=True)})\n\n        # Add first generation's p for run r\n        output.loc[ r * t_max, \"p\"] = population[ population[\"trait\"] == \"A\" ].shape[0] / N\n\n        # For each generation \n        for t in range(1,t_max):\n            # Copy individuals to previous_population DataFrame\n            previous_population = population.copy()\n\n            # Randomly compy from previous generation \n            population = population[\"trait\"].sample(N, replace=True).to_frame()\n\n            # Get p and put it into output slot for this generation t and run r\n            output.loc[r * t_max + t, \"p\"] = population[ population[\"trait\"] == \"A\" ].shape[0] / N\n\n    return output\n\n\nunbiased_transmission_2(100, 100, 3).head()\n\n\n\n\n\n  \n    \n      \n      generation\n      p\n      run\n    \n  \n  \n    \n      0\n      0\n      0.46\n      0\n    \n    \n      1\n      1\n      0.43\n      0\n    \n    \n      2\n      2\n      0.42\n      0\n    \n    \n      3\n      3\n      0.42\n      0\n    \n    \n      4\n      4\n      0.53\n      0\n    \n  \n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nWhy could we append .head() to the unbiased_transmission_2 function?\n\n\n\ndata_model = unbiased_transmission_2(N=100, t_max=200, r_max=5)\n\n\ndef plot_multiple_runs(data_model):\n    groups = data_model.groupby(\"run\")\n    for _, g in groups:\n        g.index = g[\"generation\"]\n        g[\"p\"].plot(lw=.5, ylim=(0,1))\n\n    data_model.groupby(\"generation\")[\"p\"].mean().plot(c=\"k\", lw=\"1\")\n\n\nplot_multiple_runs(data_model)\n\n\n\n\nMultiple runs of the unbiased transmission model for a population of \\(N=100\\) individuals, with average (black line).\n\n\n\n\n\ndata_model = unbiased_transmission_2(N=10_000, t_max=200, r_max=5)\n\n\nplot_multiple_runs(data_model)\n\n\n\n\nMultiple runs of the unbiased transmission model for a population of \\(N=10,000\\) individuals, with average (black line).\n\n\n\n\n\ndef unbiased_transmission_3(N, p_0, t_max, r_max):\n    output = pd.DataFrame({\n        \"generation\" : np.tile(np.arange(t_max), r_max),\n        \"p\" : [ np.nan ] * t_max * r_max,\n        \"run\" : np.repeat(np.arange(r_max), t_max)\n    })\n\n    for r in range(r_max):\n        # Create first generation\n        population = pd.DataFrame({\"trait\": rng.choice([\"A\", \"B\"], size=N, replace=True, p=[p_0, 1 - p_0])})\n\n        # Add first generation's p for run r\n        output.loc[ r * t_max, \"p\"] = population[ population[\"trait\"] == \"A\" ].shape[0] / N\n\n        # For each generation \n        for t in range(1,t_max):\n            # Copy individuals to previous_population DataFrame\n            previous_population = population\n\n            # Randomly compy from previous generation \n            population = population[\"trait\"].sample(N, replace=True).to_frame()\n\n            # Get p and put it into output slot for this generation t and run r\n            output.loc[r * t_max + t, \"p\"] = population[ population[\"trait\"] == \"A\" ].shape[0] / N\n\n    return output\n\n\ndata_model = unbiased_transmission_3(10_000, p_0=.2, t_max=200, r_max=5)\nplot_multiple_runs(data_model)\n\n\n\n\n\n\n\n\nAcerbi, A., Mesoudi, A., & Smolla, M. (2022). Individual-based models of cultural evolution: A step-by-step guide using R. Routledge. https://acerbialberto.com/IBM-cultevo/"
  },
  {
    "objectID": "chapter04.html",
    "href": "chapter04.html",
    "title": "4  Unbiased and biased mutation",
    "section": "",
    "text": "import numpy as np\nrng = np.random.default_rng()\n\nimport pandas as pd\n\n\ndef unbiased_mutation(N, mu, p_0, t_max, r_max):\n    # Create an output DataFrame\n    output = pd.DataFrame({\n        \"generation\" : np.tile(np.arange(t_max), r_max),\n        \"p\" : [ np.nan ] * t_max * r_max,\n        \"run\" : np.repeat(np.arange(r_max), t_max)\n    })\n\n    for r in range(r_max):\n        # Create first generation\n        population = pd.DataFrame({\"trait\": rng.choice([\"A\", \"B\"], size=N, replace=True, p=[p_0, 1 - p_0])})\n\n        # Add first generation's p for run r\n        output.loc[ r * t_max, \"p\"] = population[ population[\"trait\"] == \"A\" ].shape[0] / N\n\n        # For each generation \n        for t in range(1,t_max):\n            # Copy individuals to previous_population DataFrame\n            previous_population = population.copy()\n            \n            # Determine \"mutant\" individuals\n            mutate = rng.choice([True, False], size=N, p=[mu, 1-mu], replace=True)\n\n            # TODO: Something is off here! Changing the order of the conditions affects\n            # the result. Should be constant with random noise but converges to either A or B\n\n            # If there are \"mutants\" from A to B \n            conditionA = mutate & (previous_population[\"trait\"] == \"A\")\n            if conditionA.sum() > 0:\n                population.loc[conditionA, \"trait\"] = \"B\"\n\n            # If there are \"mutants\" from B to A\n            conditionB = mutate & (previous_population[\"trait\"] == \"B\")\n            if conditionB.sum() > 0:\n                population.loc[conditionB, \"trait\"] = \"A\"\n\n            # Get p and put it into output slot for this generation t and run r\n            output.loc[r * t_max + t, \"p\"] = population[ population[\"trait\"] == \"A\" ].shape[0] / N\n\n    return output \n\n\ndef plot_multiple_runs(data_model):\n    groups = data_model.groupby(\"run\")\n    for _, g in groups:\n        g.index = g[\"generation\"]\n        g[\"p\"].plot(lw=.5, ylim=(0,1))\n\n    data_model.groupby(\"generation\")[\"p\"].mean().plot(c=\"k\", lw=\"1\")\n\n\ndata_model = unbiased_mutation(N=100, mu=.05, p_0=0.5, t_max=200, r_max=5)\nplot_multiple_runs(data_model)\n\n\n\n\n\ndata_model = unbiased_mutation(N=100, mu=.05, p_0=0.1, t_max=200, r_max=5)\nplot_multiple_runs(data_model)\n\n\n\n\n\ndef biased_mutation(N, mu_b, p_0, t_max, r_max):\n    # Create the output DataFrame\n    output = pd.DataFrame({\n        \"generation\" : np.tile(np.arange(t_max), r_max),\n        \"p\" : [ np.nan ] * t_max * r_max,\n        \"run\" : np.repeat(np.arange(r_max), t_max)\n    })\n\n    for r in range(r_max):\n        # Create first generation\n        population = pd.DataFrame({\"trait\": rng.choice([\"A\", \"B\"], size=N, replace=True, p=[p_0, 1 - p_0])})\n\n        # Add first generation's p for run r\n        output.loc[ r * t_max, \"p\"] = population[ population[\"trait\"] == \"A\" ].shape[0] / N\n\n        # For each generation \n        for t in range(1,t_max):\n            # Copy individuals to previous_population DataFrame\n            previous_population = population.copy()\n            \n            # Determine \"mutant\" individuals\n            mutate = rng.choice([True, False], size=N, p=[mu_b, 1-mu_b], replace=True)\n\n            # TODO: Something is off here! Changing the order of the conditions affects\n            # the result. Should be constant with random noise but converges to either A or B\n\n            # If there are \"mutants\" from B to A\n            conditionB = mutate & (previous_population[\"trait\"] == \"B\")\n            if conditionB.sum() > 0:\n                population.loc[conditionB, \"trait\"] = \"A\"\n\n            # Get p and put it into output slot for this generation t and run r\n            output.loc[r * t_max + t, \"p\"] = population[ population[\"trait\"] == \"A\" ].shape[0] / N\n\n    return output \n\n\ndata_model = biased_mutation(N = 100, mu_b = 0.05, p_0 = 0, t_max = 200, r_max = 5)\nplot_multiple_runs(data_model)\n\n\n\n\n\ndata_model = biased_mutation(N = 10000, mu_b = 0.05, p_0 = 0, t_max = 200, r_max = 5)\nplot_multiple_runs(data_model)\n\n\n\n\n\ndata_model <- biased_mutation(N = 10000, mu_b = 0.1, p_0 = 0, t_max = 200, r_max = 5)\nplot_multiple_runs(data_model)\n\n\n\n\n\n\n\n\nAcerbi, A., Mesoudi, A., & Smolla, M. (2022). Individual-based models of cultural evolution: A step-by-step guide using R. Routledge. https://acerbialberto.com/IBM-cultevo/"
  },
  {
    "objectID": "chapter05.html",
    "href": "chapter05.html",
    "title": "5  Biased transmission: direct bias",
    "section": "",
    "text": "import numpy as np\nrng = np.random.default_rng()\nimport pandas as pd\n\n\ndef plot_multiple_runs(data_model):\n    groups = data_model.groupby(\"run\")\n    for _, g in groups:\n        g.index = g[\"generation\"]\n        g[\"p\"].plot(lw=.5, ylim=(0,1))\n\n    data_model.groupby(\"generation\")[\"p\"].mean().plot(c=\"k\", lw=\"1\")\n\n\ndef biased_transmission_direct(N, s_a, s_b, p_0, t_max, r_max):\n    # Create the output DataFrame\n    output = pd.DataFrame({\n        \"generation\" : np.tile(np.arange(t_max), r_max),\n        \"p\" : [ np.nan ] * t_max * r_max,\n        \"run\" : np.repeat(np.arange(r_max), t_max)\n    })\n\n    for r in range(r_max):\n        # Create first generation\n        population = pd.DataFrame({\"trait\": rng.choice([\"A\", \"B\"], size=N, replace=True, p=[p_0, 1 - p_0])})\n\n        # Add first generation's p for run r\n        output.loc[ r * t_max, \"p\"] = population[ population[\"trait\"] == \"A\" ].shape[0] / N\n\n        # For each generation \n        for t in range(1,t_max):\n            # Copy individuals to previous_population DataFrame\n            previous_population = population.copy()\n\n            # For each individual, pick a random individual from the previous generation\n            demonstrator_trait = previous_population[\"trait\"].sample(N, replace=True).reset_index()\n            \n            # Biased probabilities to copy\n            copy_a = rng.choice([True, False], size=N, replace=True, p=[s_a, 1 - s_a])\n            copy_b = rng.choice([True, False], size=N, replace=True, p=[s_b, 1 - s_b])\n\n            # If the demonstrator has trait A and the individual wants to copy A, then copy A\n            condition = copy_a & (demonstrator_trait[\"trait\"] == \"A\")\n            if condition.sum() > 0:\n                population.loc[condition, \"trait\"] = \"A\"\n\n            # If the demonstrator has trait B and the individual wants to copy B, then copy B\n            condition = copy_b & (demonstrator_trait[\"trait\"] == \"B\")\n            if condition.sum() > 0:\n                population.loc[condition, \"trait\"] = \"B\"\n\n            # Get p and put it into output slot for this generation t and run r\n            output.loc[r * t_max + t, \"p\"] = population[ population[\"trait\"] == \"A\" ].shape[0] / N\n\n    return output \n\n\ndata_model = biased_transmission_direct(N=10_000, s_a=.1, s_b=0, \n                                         p_0=.01, t_max=200, r_max=5)\nplot_multiple_runs(data_model)\n\n\n\n\n\ndata_model = biased_transmission_direct(N=10_000, s_a=.6, s_b=.5, \n                                         p_0=.01, t_max=150, r_max=5)\nplot_multiple_runs(data_model)\n\n\n\n\n\ndata_model = biased_transmission_direct(N=10_000, s_a=.2, s_b=0, \n                                         p_0=.01, t_max=200, r_max=5)\nplot_multiple_runs(data_model)\n\n\n\n\n\n\n\n\nAcerbi, A., Mesoudi, A., & Smolla, M. (2022). Individual-based models of cultural evolution: A step-by-step guide using R. Routledge. https://acerbialberto.com/IBM-cultevo/"
  },
  {
    "objectID": "chapter06.html",
    "href": "chapter06.html",
    "title": "6  Biased transmission: frequency-dependent indirect bias",
    "section": "",
    "text": "import numpy as np \nrng = np.random.default_rng()\n\nimport pandas as pd\n\n\ndef plot_multiple_runs(data_model):\n    groups = data_model.groupby(\"run\")\n    for _, g in groups:\n        g.index = g[\"generation\"]\n        g[\"p\"].plot(lw=.5, ylim=(0,1))\n\n    data_model.groupby(\"generation\")[\"p\"].mean().plot(c=\"k\", lw=\"1\")\n\n\nN = 100\np_0 = .5\nD = 1.\n\n\n# Create first generation\npopulation = pd.DataFrame({\"trait\": rng.choice([\"A\", \"B\"], size=N, replace=True, p=[p_0, 1-p_0])})\n\n\n# Create a DataFrame with a set of 3 randomly-picked demonstrators for each agent\n\ndemonstrators = pd.DataFrame({\n    \"dem1\" : population[\"trait\"].sample(N, replace=True).values,\n    \"dem2\" : population[\"trait\"].sample(N, replace=True).values,\n    \"dem3\" : population[\"trait\"].sample(N, replace=True).values\n})\n\n\n# Visualize the DataFrame\ndemonstrators.head()\n\n\n\n\n\n  \n    \n      \n      dem1\n      dem2\n      dem3\n    \n  \n  \n    \n      0\n      A\n      A\n      A\n    \n    \n      1\n      B\n      A\n      B\n    \n    \n      2\n      A\n      B\n      B\n    \n    \n      3\n      A\n      A\n      B\n    \n    \n      4\n      B\n      A\n      A\n    \n  \n\n\n\n\n\n# Get the number of A's in each 3-demonstrator combination\nnum_As = (demonstrators == \"A\").apply(sum, axis=1)\nnum_As.head()\n\n0    3\n1    1\n2    1\n3    2\n4    2\ndtype: int64\n\n\n\n# For 3-demonstrator combinations with all A's, set to A\npopulation[ num_As == 3 ] = \"A\"\n# For 3-demonstrator combinations with all B's, set to B\npopulation[ num_As == 0 ] = \"B\"\n\n\nprob_majority = rng.choice([True, False], p=[(2/3 + D/3), 1-(2/3 + D/3)], size=N, replace=True)\nprob_minority = rng.choice([True, False], p=[(1/3 + D/3), 1-(1/3 + D/3)], size=N, replace=True)\n\n\n# 3-demonstrator combinations with two As and one B\ncondition = prob_majority & (num_As == 2)\nif condition.sum() > 0:\n    population.loc[condition, \"trait\"] = \"A\"\ncondition = ~prob_majority & (num_As == 2)\nif condition.sum() > 0:\n    population.loc[condition, \"trait\"] = \"B\"\n\n# 3-demonstrator combinations with two B's and one A\ncondition = ~prob_minority & (num_As == 1)\nif condition.sum() > 0:\n    population.loc[condition, \"trait\"] = \"A\"\ncondition = prob_minority & (num_As == 1)\nif condition.sum() > 0:\n    population.loc[condition, \"trait\"] = \"B\"\n\n\ndemonstrators[\"new_trait\"] = population[\"trait\"]\ndemonstrators.head()\n\n\n\n\n\n  \n    \n      \n      dem1\n      dem2\n      dem3\n      new_trait\n    \n  \n  \n    \n      0\n      A\n      A\n      A\n      A\n    \n    \n      1\n      B\n      A\n      B\n      B\n    \n    \n      2\n      A\n      B\n      B\n      B\n    \n    \n      3\n      A\n      A\n      B\n      A\n    \n    \n      4\n      B\n      A\n      A\n      A\n    \n  \n\n\n\n\n\ndef conformist_transmission(N, p_0, D, t_max, r_max):\n    # Create the output DataFrame\n    output = pd.DataFrame({\n        \"generation\" : np.tile(np.arange(t_max), r_max),\n        \"p\" : [ np.nan ] * t_max * r_max,\n        \"run\" : np.repeat(np.arange(r_max), t_max)\n    })\n\n    for r in range(r_max):\n        # Create first generation\n        population = pd.DataFrame({\"trait\": rng.choice([\"A\", \"B\"], size=N, replace=True, p=[p_0, 1 - p_0])})\n\n        # Add first generation's p for run r\n        output.loc[ r * t_max, \"p\"] = population[ population[\"trait\"] == \"A\" ].shape[0] / N\n\n        # For each generation \n        for t in range(1,t_max):\n            demonstrators = pd.DataFrame({\n                \"dem1\" : population[\"trait\"].sample(N, replace=True).values,\n                \"dem2\" : population[\"trait\"].sample(N, replace=True).values,\n                \"dem3\" : population[\"trait\"].sample(N, replace=True).values\n            })\n\n            # Get the number of A's in each 3-demonstrator combination\n            num_As = (demonstrators == \"A\").apply(sum, axis=1)\n\n            # For 3-demonstrator combinations with all A's, set to A\n            population[ num_As == 3 ] = \"A\"\n            # For 3-demonstrator combinations with all A's, set to A\n            population[ num_As == 3 ] = \"A\"\n            # For 3-demonstrator combinations with all B's, set to B\n            population[ num_As == 0 ] = \"B\"\n\n            prob_majority = rng.choice([True, False], p=[(2/3 + D/3), 1-(2/3 + D/3)], size=N, replace=True)\n            prob_minority = rng.choice([True, False], p=[(1/3 + D/3), 1-(1/3 + D/3)], size=N, replace=True)\n\n            # 3-demonstrator combinations with two As and one B\n            condition = prob_majority & (num_As == 2)\n            if condition.sum() > 0:\n                population.loc[condition, \"trait\"] = \"A\"\n            condition = ~prob_majority & (num_As == 2)\n            if condition.sum() > 0:\n                population.loc[condition, \"trait\"] = \"B\"\n\n            # 3-demonstrator combinations with two B's and one A\n            condition = prob_minority & (num_As == 1)\n            if condition.sum() > 0:\n                population.loc[condition, \"trait\"] = \"A\"\n            condition = ~prob_minority & (num_As == 1)\n            if condition.sum() > 0:\n                population.loc[condition, \"trait\"] = \"B\"\n            \n            # Get p and put it into output slot for this generation t and run r\n            output.loc[r * t_max + t, \"p\"] = population[ population[\"trait\"] == \"A\" ].shape[0] / N\n\n    return output\n\n\ndata_model = conformist_transmission(N=1_000, p_0 = 0.5, D = 1, t_max = 50, r_max = 10)\nplot_multiple_runs(data_model)\n\n\n\n\n\n\n\n\nAcerbi, A., Mesoudi, A., & Smolla, M. (2022). Individual-based models of cultural evolution: A step-by-step guide using R. Routledge. https://acerbialberto.com/IBM-cultevo/"
  },
  {
    "objectID": "chapter07.html",
    "href": "chapter07.html",
    "title": "7  Biased transmission: demonstrator-based indirect bias",
    "section": "",
    "text": "import numpy as np \nrng = np.random.default_rng()\n\nimport pandas as pd\n\n\ndef plot_multiple_runs(data_model):\n    groups = data_model.groupby(\"run\")\n    for _, g in groups:\n        g.index = g[\"generation\"]\n        g[\"p\"].plot(lw=.5, ylim=(0,1))\n\n    data_model.groupby(\"generation\")[\"p\"].mean().plot(c=\"k\", lw=\"1\")\n\n\nN = 100\np_0 = 0.5\np_s = 0.05\n\n\npopulation = pd.DataFrame({\n    \"trait\": rng.choice([\"A\", \"B\"], size=N, replace=True, p=[p_0, 1-p_0]),\n    \"status\": rng.choice([\"high\", \"low\"], size=N, replace=True, p=[p_s, 1-p_s])\n})\n\n\npopulation.head()\n\n\n\n\n\n  \n    \n      \n      trait\n      status\n    \n  \n  \n    \n      0\n      B\n      low\n    \n    \n      1\n      B\n      low\n    \n    \n      2\n      A\n      low\n    \n    \n      3\n      A\n      low\n    \n    \n      4\n      A\n      low\n    \n  \n\n\n\n\n\np_low = 0.01\np_demonstrator = np.ones(N)\np_demonstrator[ population[\"status\"] == \"low\" ] = p_low\n\n\nif sum(p_demonstrator) > 0:\n    ps = p_demonstrator / p_demonstrator.sum()\n    demonstrator_index = rng.choice(np.arange(N), size=N, p=ps, replace=True)\n    population[\"trait\"] = population.loc[demonstrator_index, \"trait\"].values\n\n\ndef biased_transmission_demonstrator(N, p_0, p_s, p_low, t_max, r_max):\n    # Create the output DataFrame\n    output = pd.DataFrame({\n        \"generation\" : np.tile(np.arange(t_max), r_max),\n        \"p\" : [ np.nan ] * t_max * r_max,\n        \"run\" : np.repeat(np.arange(r_max), t_max)\n    })\n    \n    for r in range(r_max):\n            # Create first generation\n            population = pd.DataFrame({\n                \"trait\": rng.choice([\"A\", \"B\"], size=N, replace=True, p=[p_0, 1-p_0]),\n                \"status\": rng.choice([\"high\", \"low\"], size=N, replace=True, p=[p_s, 1-p_s])\n            })\n            \n            # Assign copying probabilities based on individuals' status\n            p_demonstrator = np.ones(N)\n            p_demonstrator[population[\"status\"] == \"low\"] = p_low\n            \n            # Add first generation's p for run r\n            output.loc[ r * t_max, \"p\"] = population[ population[\"trait\"] == \"A\" ].shape[0] / N\n            \n            for t in range(1, t_max):\n                # Copy individuals to previous_population DataFrame\n                previous_population = population.copy()\n                \n                # Copy traits based on status\n                if sum(p_demonstrator) > 0:\n                    ps = p_demonstrator / p_demonstrator.sum()\n                    demonstrator_index = rng.choice(np.arange(N), size=N, p=ps, replace=True)\n                    population[\"trait\"] = population.loc[demonstrator_index, \"trait\"].values\n                \n                # Get p and put it into output slot for this generation t and run r\n                output.loc[r * t_max + t, \"p\"] = population[ population[\"trait\"] == \"A\" ].shape[0] / N\n                \n    return output\n\n\ndata_model = biased_transmission_demonstrator(N=100, p_s=0.05, p_low=0.0001, p_0=0.5, t_max=50, r_max=10)\n\n\nplot_multiple_runs(data_model)\n\n\n\n\n\ndata_model = biased_transmission_demonstrator(N=10_000, p_s=0.005, p_low=0.0001, p_0=0.5, t_max=200, r_max=10)\nplot_multiple_runs(data_model)\n\n\n\n\n\ndef biased_transmission_demonstrator_2(N, p_0, p_s, p_low, t_max, r_max):\n    # Create the output DataFrame\n    output = pd.DataFrame({\n        \"generation\" : np.tile(np.arange(t_max), r_max),\n        \"p\" : [ np.nan ] * t_max * r_max,\n        \"run\" : np.repeat(np.arange(r_max), t_max)\n    })\n    \n    ...\n    \n    return output\n\n\ndata_model = biased_transmission_demonstrator_2(N=100, p_s=0.1, p_low=0.0001, p_0=0.5, t_max=50, r_max=50)\n\n\n\n\n\nAcerbi, A., Mesoudi, A., & Smolla, M. (2022). Individual-based models of cultural evolution: A step-by-step guide using R. Routledge. https://acerbialberto.com/IBM-cultevo/"
  },
  {
    "objectID": "chapter08.html",
    "href": "chapter08.html",
    "title": "8  Vertical and horizontal transmission",
    "section": "",
    "text": "Note\n\n\n\nThis chapter is based on “Chapter 6: Vertical and horizontal transmission” in Acerbi et al. (2022)."
  },
  {
    "objectID": "chapter08.html#sec-vertical-transmission",
    "href": "chapter08.html#sec-vertical-transmission",
    "title": "8  Vertical and horizontal transmission",
    "section": "8.1 Vertical cultural transmission",
    "text": "8.1 Vertical cultural transmission\n\nimport numpy as np \nrng = np.random.default_rng()\n\nimport pandas as pd\nfrom tqdm import tqdm\n\n\ndef plot_multiple_runs(data_model):\n    groups = data_model.groupby(\"run\")\n    for _, g in groups:\n        g.index = g[\"generation\"]\n        g[\"p\"].plot(lw=.5, ylim=(0,1))\n\n    data_model.groupby(\"generation\")[\"p\"].mean().plot(c=\"k\", lw=\"1\")\n\n\ndef vertical_transmission(N, p_0, b, t_max, r_max):\n    # Create the output DataFrame\n    output = pd.DataFrame({\n        \"generation\" : np.tile(np.arange(t_max), r_max),\n        \"p\" : [ np.nan ] * t_max * r_max,\n        \"run\" : np.repeat(np.arange(r_max), t_max)\n    })\n\n    for r in range(r_max): \n        # Create first generation\n        population = pd.DataFrame({\"trait\": rng.choice([\"A\", \"B\"], size=N, replace=True, p=[p_0, 1 - p_0])})\n\n        # Add first generation's p for run r\n        output.loc[ r * t_max, \"p\"] = population[ population[\"trait\"] == \"A\" ].shape[0] / N\n\n        # # For each generation \n        for t in range(1, t_max): \n            # Copy individuals to previous_population DataFrame\n            previous_population = population.copy()\n\n            # randomly pick mothers and fathers\n            mother = previous_population[\"trait\"].sample(N, replace=True).reset_index(drop=True)\n            father = previous_population[\"trait\"].sample(N, replace=True).reset_index(drop=True)\n\n            # prepare next generation\n            population = pd.DataFrame({\"trait\": [np.nan] * N })\n\n            # Both parents are A, thus child adopts A\n            both_A = (mother == \"A\") & (father == \"A\")\n            # if sum(both_A) > 0:\n            population.loc[both_A,\"trait\"] = \"A\"\n\n            # Both parents are A, thus child adopts A\n            both_B = (mother == \"B\") & (father == \"B\")\n            # if sum(both_B) > 0:\n            population.loc[both_B,\"trait\"] = \"B\"\n\n            # If any empty NA slots are present (i.e. one A and one B parent) they adopt A with probability b\n            remaining = rng.choice([\"A\", \"B\"], size=population[\"trait\"].isna().sum(), replace=True, p=[b, 1 - b])\n            population.loc[population[\"trait\"].isna(),\"trait\"] = remaining\n            \n            # Get p and put it into output slot for this generation t and run r\n            output.loc[r * t_max + t, \"p\"] = population[ population[\"trait\"] == \"A\" ].shape[0] / N\n\n    return output \n\n\ndata_model = vertical_transmission(N=10_000, p_0=0.01, b=0.6,t_max=50, r_max=5)\n\nplot_multiple_runs(data_model)\n\n\n\n\n\ndata_model = vertical_transmission(N=10_000, p_0=0.1, b=0.5,t_max=50, r_max=5)\nplot_multiple_runs(data_model)"
  },
  {
    "objectID": "chapter08.html#horizontal-cultural-transmission",
    "href": "chapter08.html#horizontal-cultural-transmission",
    "title": "8  Vertical and horizontal transmission",
    "section": "8.2 Horizontal cultural transmission",
    "text": "8.2 Horizontal cultural transmission\n\n\n\n\n\n\nWarning\n\n\n\nThe code below is not yet correct and runs very slowly.\n\n\n\ndef vertical_horizontal_transmission(N, p_0, b, n, g, t_max, r_max):\n    # Create the output DataFrame\n    output = pd.DataFrame({\n        \"generation\" : np.tile(np.arange(t_max), r_max),\n        \"p\" : [ np.nan ] * t_max * r_max,\n        \"run\" : np.repeat(np.arange(r_max), t_max)\n    })\n\n    for r in range(r_max):\n        # Create first generation\n        population = pd.DataFrame({\"trait\": rng.choice([\"A\", \"B\"], size=N, replace=True, p=[p_0, 1 - p_0])})\n\n        # Add first generation's p for run r\n        output.loc[ r * t_max, \"p\"] = population[ population[\"trait\"] == \"A\" ].shape[0] / N\n\n        # For each generation \n        for t in tqdm(range(t_max)):\n            ### Vertical transmission =========================================================\n\n            # Copy individuals to previous_population DataFrame\n            previous_population = population.copy()\n\n            # randomly pick mothers and fathers\n            mother = previous_population[\"trait\"].sample(N, replace=True).reset_index(drop=True)\n            father = previous_population[\"trait\"].sample(N, replace=True).reset_index(drop=True)\n\n            # prepare next generation\n            population = pd.DataFrame({\"trait\": [np.nan] * N })\n\n            # Both parents are A, thus child adopts A\n            both_A = (mother == \"A\") & (father == \"A\")\n            # if sum(both_A) > 0:\n            population.loc[both_A,\"trait\"] = \"A\"\n\n            # Both parents are A, thus child adopts A\n            both_B = (mother == \"B\") & (father == \"B\")\n            # if sum(both_B) > 0:\n            population.loc[both_B,\"trait\"] = \"B\"\n\n            # If any empty NA slots are present (i.e. one A and one B parent) they adopt A with probability b\n            remaining = rng.choice([\"A\", \"B\"], size=population[\"trait\"].isna().sum(), replace=True, p=[b, 1 - b])\n            population.loc[population[\"trait\"].isna(),\"trait\"] = remaining\n            \n            # Get p and put it into output slot for this generation t and run r\n            output.loc[r * t_max + t, \"p\"] = population[ population[\"trait\"] == \"A\" ].shape[0] / N\n\n            # ### Horizontal transmission =========================================================\n\n            # previous_population = population.copy()\n            # # # N_B = number of Bs\n            # N_B = previous_population[previous_population[\"trait\"] == \"B\"].shape[0]\n\n            # # if there are B individuals to switch, and n is not zero:\n            # if (N_B > 0) & (n > 0):\n            #     # for each B individual:\n            #     for i in range(N_B):\n            #         # Pick n demonstrators\n            #         demonstrator = previous_population[\"trait\"].sample(n, replace=True)\n            #         # Get probability g \n            #         copy_ = rng.choice([True, False], n, p=[g, 1 - g], replace=True)\n            #         # if any demonstrators with A are to be copied:\n            #         if sum((demonstrator == \"A\") & (copy_)) > 0:\n            #           # The B individual switches to A \n            #           population[previous_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n\n            next_population = population.copy()\n            # # N_B = number of Bs\n            N_B = next_population[next_population[\"trait\"] == \"B\"].shape[0]\n\n            # if there are B individuals to switch, and n is not zero:\n            if (N_B > 0) & (n > 0):\n                # for each B individual:\n                for i in range(N_B):\n                    # Pick n demonstrators\n                    demonstrator = population[\"trait\"].sample(n, replace=True)\n                    # Get probability g \n                    copy_ = rng.choice([True, False], n, p=[g, 1 - g], replace=True)\n                    # if any demonstrators with A are to be copied:\n                    if sum((demonstrator == \"A\") & (copy_)) > 0:\n                      # The B individual switches to A \n                      next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n\n            # Get p and put it into output slot for this generation t and run r\n            output.loc[r * t_max + t, \"p\"] = next_population[ next_population[\"trait\"] == \"A\" ].shape[0] / N\n\n    return output\n\n\nvertical_horizontal_transmission(N=1000, p_0=0.01, b=0.5, n=5, g=0.1, t_max=10, r_max=1)\n\n  0%|          | 0/10 [00:00<?, ?it/s]\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n\n\n 10%|█         | 1/10 [00:00<00:03,  2.40it/s]\n\n\n 20%|██        | 2/10 [00:00<00:02,  2.88it/s]\n\n\n 30%|███       | 3/10 [00:00<00:02,  3.22it/s]\n\n\n 40%|████      | 4/10 [00:01<00:01,  3.27it/s]\n\n\n 50%|█████     | 5/10 [00:01<00:01,  3.39it/s]\n\n\n 60%|██████    | 6/10 [00:01<00:01,  3.48it/s]\n\n\n 70%|███████   | 7/10 [00:02<00:00,  3.43it/s]\n\n\n 80%|████████  | 8/10 [00:02<00:00,  3.56it/s]\n\n\n 90%|█████████ | 9/10 [00:02<00:00,  3.43it/s]\n\n\n100%|██████████| 10/10 [00:02<00:00,  3.48it/s]\n\n\n100%|██████████| 10/10 [00:02<00:00,  3.35it/s]\n\n\n\n\n\n\n\n\n\n  \n    \n      \n      generation\n      p\n      run\n    \n  \n  \n    \n      0\n      0\n      0.013\n      0\n    \n    \n      1\n      1\n      0.010\n      0\n    \n    \n      2\n      2\n      0.007\n      0\n    \n    \n      3\n      3\n      0.006\n      0\n    \n    \n      4\n      4\n      0.004\n      0\n    \n    \n      5\n      5\n      0.005\n      0\n    \n    \n      6\n      6\n      0.007\n      0\n    \n    \n      7\n      7\n      0.005\n      0\n    \n    \n      8\n      8\n      0.005\n      0\n    \n    \n      9\n      9\n      0.003\n      0\n    \n  \n\n\n\n\n\ndata_model = vertical_horizontal_transmission(N=5_000, p_0=0.01, b=0.5, n=5, g=0.1, t_max=50, r_max=2)\nplot_multiple_runs(data_model)\n\n  0%|          | 0/50 [00:00<?, ?it/s]\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n\n\n  2%|▏         | 1/50 [00:01<01:19,  1.63s/it]\n\n\n  4%|▍         | 2/50 [00:03<01:18,  1.63s/it]\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n\n\n  6%|▌         | 3/50 [00:04<01:13,  1.57s/it]\n\n\n  8%|▊         | 4/50 [00:06<01:11,  1.55s/it]\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n\n\n 10%|█         | 5/50 [00:07<01:11,  1.59s/it]\n\n\n 12%|█▏        | 6/50 [00:09<01:10,  1.61s/it]\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n\n\n 14%|█▍        | 7/50 [00:11<01:11,  1.65s/it]\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n 16%|█▌        | 8/50 [00:13<01:10,  1.67s/it]\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n\n\n 18%|█▊        | 9/50 [00:15<01:18,  1.92s/it]\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n\n\n 20%|██        | 10/50 [00:17<01:15,  1.88s/it]\n\n\n 22%|██▏       | 11/50 [00:19<01:13,  1.89s/it]\n\n\n 24%|██▍       | 12/50 [00:20<01:07,  1.77s/it]\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n\n\n 26%|██▌       | 13/50 [00:22<01:03,  1.73s/it]\n\n\n 28%|██▊       | 14/50 [00:23<01:01,  1.71s/it]\n\n\n 30%|███       | 15/50 [00:25<00:59,  1.69s/it]\n\n\n 32%|███▏      | 16/50 [00:27<00:57,  1.69s/it]\n\n\n 34%|███▍      | 17/50 [00:29<00:55,  1.70s/it]\n\n\n 36%|███▌      | 18/50 [00:30<00:55,  1.73s/it]\n\n\n 38%|███▊      | 19/50 [00:32<00:56,  1.82s/it]\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n\n\n 40%|████      | 20/50 [00:34<00:54,  1.81s/it]\n\n\n 42%|████▏     | 21/50 [00:36<00:51,  1.79s/it]\n\n\n 44%|████▍     | 22/50 [00:38<00:52,  1.88s/it]\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n\n\n 46%|████▌     | 23/50 [00:40<00:49,  1.84s/it]\n\n\n 48%|████▊     | 24/50 [00:41<00:46,  1.79s/it]\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n\n\n 50%|█████     | 25/50 [00:43<00:45,  1.81s/it]\n\n\n 52%|█████▏    | 26/50 [00:45<00:45,  1.89s/it]\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n\n\n 54%|█████▍    | 27/50 [00:47<00:41,  1.81s/it]\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n\n\n 56%|█████▌    | 28/50 [00:49<00:38,  1.76s/it]\n\n\n 58%|█████▊    | 29/50 [00:50<00:35,  1.71s/it]\n\n\n 60%|██████    | 30/50 [00:52<00:33,  1.69s/it]\n\n\n 62%|██████▏   | 31/50 [00:54<00:32,  1.70s/it]\n\n\n 64%|██████▍   | 32/50 [00:55<00:29,  1.66s/it]\n\n\n 66%|██████▌   | 33/50 [00:57<00:30,  1.78s/it]\n\n\n 68%|██████▊   | 34/50 [00:59<00:28,  1.81s/it]\n\n\n 70%|███████   | 35/50 [01:01<00:26,  1.76s/it]\n\n\n 72%|███████▏  | 36/50 [01:03<00:25,  1.84s/it]\n\n\n 74%|███████▍  | 37/50 [01:05<00:25,  1.93s/it]\n\n\n 76%|███████▌  | 38/50 [01:07<00:24,  2.04s/it]\n\n\n 78%|███████▊  | 39/50 [01:09<00:21,  1.92s/it]\n\n\n 80%|████████  | 40/50 [01:10<00:17,  1.77s/it]\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n\n\n 82%|████████▏ | 41/50 [01:12<00:15,  1.73s/it]\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n 84%|████████▍ | 42/50 [01:14<00:13,  1.74s/it]\n\n\n 86%|████████▌ | 43/50 [01:15<00:11,  1.67s/it]\n\n\n 88%|████████▊ | 44/50 [01:17<00:09,  1.63s/it]\n\n\n 90%|█████████ | 45/50 [01:18<00:07,  1.59s/it]\n\n\n 92%|█████████▏| 46/50 [01:20<00:06,  1.59s/it]\n\n\n 94%|█████████▍| 47/50 [01:21<00:04,  1.58s/it]\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n\n\n 96%|█████████▌| 48/50 [01:23<00:03,  1.59s/it]\n\n\n 98%|█████████▊| 49/50 [01:25<00:01,  1.64s/it]\n\n\n100%|██████████| 50/50 [01:26<00:00,  1.64s/it]\n\n\n100%|██████████| 50/50 [01:26<00:00,  1.74s/it]\n\n\n\n\n\n  0%|          | 0/50 [00:00<?, ?it/s]\n\n\n  2%|▏         | 1/50 [00:01<01:10,  1.45s/it]\n\n\n  4%|▍         | 2/50 [00:02<01:10,  1.47s/it]\n\n\n  6%|▌         | 3/50 [00:04<01:08,  1.46s/it]\n\n\n  8%|▊         | 4/50 [00:05<01:08,  1.48s/it]\n\n\n 10%|█         | 5/50 [00:07<01:07,  1.50s/it]\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n\n\n 12%|█▏        | 6/50 [00:08<01:06,  1.50s/it]\n\n\n 14%|█▍        | 7/50 [00:10<01:04,  1.50s/it]\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n 16%|█▌        | 8/50 [00:11<01:02,  1.49s/it]\n\n\n 18%|█▊        | 9/50 [00:13<01:01,  1.51s/it]\n\n\n 20%|██        | 10/50 [00:15<01:03,  1.59s/it]\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n\n\n 22%|██▏       | 11/50 [00:16<01:02,  1.60s/it]\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n\n\n 24%|██▍       | 12/50 [00:18<01:01,  1.62s/it]\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n\n\n 26%|██▌       | 13/50 [00:20<00:59,  1.61s/it]\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n\n\n 28%|██▊       | 14/50 [00:21<00:59,  1.65s/it]\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n\n\n 30%|███       | 15/50 [00:23<00:59,  1.69s/it]\n\n\n 32%|███▏      | 16/50 [00:25<00:59,  1.75s/it]\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n\n\n 34%|███▍      | 17/50 [00:27<00:59,  1.79s/it]\n\n\n 36%|███▌      | 18/50 [00:29<00:57,  1.78s/it]\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n 38%|███▊      | 19/50 [00:30<00:55,  1.79s/it]\n\n\n 40%|████      | 20/50 [00:32<00:53,  1.78s/it]\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n\n\n 42%|████▏     | 21/50 [00:34<00:51,  1.76s/it]\n\n\n 44%|████▍     | 22/50 [00:35<00:47,  1.70s/it]\n\n\n 46%|████▌     | 23/50 [00:37<00:46,  1.72s/it]\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n\n\n 48%|████▊     | 24/50 [00:39<00:44,  1.72s/it]\n\n\n 50%|█████     | 25/50 [00:41<00:42,  1.70s/it]\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n\n\n 52%|█████▏    | 26/50 [00:42<00:40,  1.71s/it]\n\n\n 54%|█████▍    | 27/50 [00:44<00:39,  1.70s/it]\n\n\n 56%|█████▌    | 28/50 [00:46<00:36,  1.66s/it]\n\n\n 58%|█████▊    | 29/50 [00:47<00:34,  1.64s/it]\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n\n\n 60%|██████    | 30/50 [00:49<00:33,  1.66s/it]\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n\n\n 62%|██████▏   | 31/50 [00:51<00:31,  1.67s/it]\n\n\n 64%|██████▍   | 32/50 [00:52<00:30,  1.71s/it]\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n\n\n 66%|██████▌   | 33/50 [00:54<00:29,  1.71s/it]\n\n\n 68%|██████▊   | 34/50 [00:56<00:27,  1.69s/it]\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n\n\n 70%|███████   | 35/50 [00:57<00:25,  1.71s/it]\n\n\n 72%|███████▏  | 36/50 [00:59<00:25,  1.80s/it]\n\n\n 74%|███████▍  | 37/50 [01:01<00:23,  1.80s/it]\n\n\n 76%|███████▌  | 38/50 [01:03<00:21,  1.80s/it]\n\n\n 78%|███████▊  | 39/50 [01:05<00:20,  1.82s/it]\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n\n\n 80%|████████  | 40/50 [01:07<00:17,  1.74s/it]\n\n\n 82%|████████▏ | 41/50 [01:08<00:15,  1.70s/it]\n\n\n 84%|████████▍ | 42/50 [01:10<00:13,  1.66s/it]\n\n\n 86%|████████▌ | 43/50 [01:11<00:11,  1.60s/it]\n\n\n 88%|████████▊ | 44/50 [01:13<00:09,  1.58s/it]\n\n\n 90%|█████████ | 45/50 [01:14<00:07,  1.54s/it]\n\n\n 92%|█████████▏| 46/50 [01:16<00:06,  1.55s/it]\n\n\n 94%|█████████▍| 47/50 [01:17<00:04,  1.55s/it]\n\n\n 96%|█████████▌| 48/50 [01:19<00:03,  1.56s/it]\n\n\n 98%|█████████▊| 49/50 [01:20<00:01,  1.53s/it]\n\n\n/tmp/ipykernel_35417/3300034538.py:81: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  next_population[next_population[\"trait\"] == \"B\"].loc[i, \"trait\"] = \"A\"\n\n\n100%|██████████| 50/50 [01:23<00:00,  1.82s/it]\n\n\n100%|██████████| 50/50 [01:23<00:00,  1.67s/it]\n\n\n\n\n\n\n\n\n\n\n\n\nAcerbi, A., Mesoudi, A., & Smolla, M. (2022). Individual-based models of cultural evolution: A step-by-step guide using R. Routledge. https://acerbialberto.com/IBM-cultevo/"
  },
  {
    "objectID": "chapter09.html",
    "href": "chapter09.html",
    "title": "9  The multiple traits model",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\nrng = np.random.default_rng()\n\nimport matplotlib.pyplot as plt\n\nN = 100\npopulation = pd.DataFrame(\n    {\"trait\" : rng.integers(N, size=N)}\n)"
  },
  {
    "objectID": "chapter09.html#introducing-innovation",
    "href": "chapter09.html#introducing-innovation",
    "title": "9  The multiple traits model",
    "section": "9.1 Introducing innovation",
    "text": "9.1 Introducing innovation"
  },
  {
    "objectID": "advanced.html",
    "href": "advanced.html",
    "title": "10  Advanced topics",
    "section": "",
    "text": "“The role of population size in folk tune complexity” (Street et al., 2022)"
  },
  {
    "objectID": "advanced.html#evolution-of-pitches-and-intervals",
    "href": "advanced.html#evolution-of-pitches-and-intervals",
    "title": "10  Advanced topics",
    "section": "10.2 Evolution of pitches and intervals",
    "text": "10.2 Evolution of pitches and intervals\n\n“Cross-cultural data shows musical scales evolved to maximise imperfect fifths” McBride & Tlusty (2020)\n“The line of fifths and the co-evolution of tonal pitch-classes” (Moss et al., 2022)"
  },
  {
    "objectID": "advanced.html#stylistic-change",
    "href": "advanced.html#stylistic-change",
    "title": "10  Advanced topics",
    "section": "10.3 Stylistic change",
    "text": "10.3 Stylistic change\nThe question of historical change is intricably related to musical styles. Here, we adopt the framework for style analysis layed out by Meyer (1989). In particular, the adaptation of Jan (2016) and its schematic representation is already almost a description of a statistical graphical model.\n\n“Statistical Evolutionary Laws in Music Styles” (Nakamura & Kaneko, 2019)\n“Investigating style evolution of Western classical music: A computational approach” (Weiß et al., 2019)"
  },
  {
    "objectID": "advanced.html#cultural-evolution-of-electronic-music",
    "href": "advanced.html#cultural-evolution-of-electronic-music",
    "title": "10  Advanced topics",
    "section": "10.4 Cultural evolution of electronic music",
    "text": "10.4 Cultural evolution of electronic music\n\n“Phylogenetic reconstruction of the cultural evolution of electronic music via dynamic community detection (1975–1999)” (Youngblood et al., 2021)\n\n\n\n\n\nJan, S. (2016). The Memetics of Music: A Neo-Darwinian View of Musical Structure and Culture. Routledge.\n\n\nMcBride, J. M., & Tlusty, T. (2020). Cross-cultural data shows musical scales evolved to maximise imperfect fifths. http://arxiv.org/abs/1906.06171\n\n\nMeyer, L. B. (1989). Style and Music. Theory, History, and Ideology. University of Chicago Press.\n\n\nMoss, F. C., Neuwirth, M., & Rohrmeier, M. (2022). The line of fifths and the co-evolution of tonal pitch-classes. Journal of Mathematics and Music, 1–25. https://doi.org/10.1080/17459737.2022.2044927\n\n\nNakamura, E., & Kaneko, K. (2019). Statistical evolutionary laws in music styles. Nature Scientific Reports, 9(1), 15993. https://doi.org/10.1038/s41598-019-52380-6\n\n\nStreet, S., Eerola, T., & Kendal, J. R. (2022). The role of population size in folk tune complexity. Humanities and Social Sciences Communications, 9(1), 1–12. https://doi.org/10.1057/s41599-022-01139-y\n\n\nWeiß, C., Mauch, M., Dixon, S., & Müller, M. (2019). Investigating style evolution of Western classical music: A computational approach. Musicae Scientiae, 23(4), 486–507. https://doi.org/10.1177/1029864918757595\n\n\nYoungblood, M., Baraghith, K., & Savage, P. E. (2021). Phylogenetic reconstruction of the cultural evolution of electronic music via dynamic community detection (1975–1999). Evolution and Human Behavior. https://doi.org/10.1016/j.evolhumbehav.2021.06.002"
  },
  {
    "objectID": "conclusion.html#what-is-the-role-of-models-for-musicology",
    "href": "conclusion.html#what-is-the-role-of-models-for-musicology",
    "title": "11  Conclusion",
    "section": "11.2 What is the role of models for musicology",
    "text": "11.2 What is the role of models for musicology"
  },
  {
    "objectID": "conclusion.html#avenues-for-future-research",
    "href": "conclusion.html#avenues-for-future-research",
    "title": "11  Conclusion",
    "section": "11.3 Avenues for future research",
    "text": "11.3 Avenues for future research"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Acerbi, A., Mesoudi, A., & Smolla, M. (2022). Individual-based models of cultural evolution: A\nstep-by-step guide using R. Routledge. https://acerbialberto.com/IBM-cultevo/\n\n\nAunger, R. (2001). Darwinizing Culture: The\nStatus of Memetics as a Science.\nOxford University Press, USA. http://gen.lib.rus.ec/book/index.php?md5=7329e2aa9adcddfed967088219426193\n\n\nBlackmore, S. (2000). The Meme Machine.\nOxford University Press.\n\n\nBoyd, R., & Richerson, P. J. (1985). Culture and the Evolutionary Process. The\nUniversity of Chicago Press.\n\n\nCavalli-Sforza, L. L., & Feldman, M. W. (1981). Cultural\nTransmission and Evolution.\nPrinceton University Press.\n\n\nCross, I. (2016). The nature of music and its evolution. In S. Hallam,\nI. Cross, & M. Thaut (Eds.), The Oxford Handbook of\nMusic Psychology (2nd ed., pp. 1–20). Oxford\nUniversity Press. https://doi.org/10.1093/oxfordhb/9780199298457.013.0001\n\n\nDawkins, R. (1976). The Selfish Gene. Oxford\nUniversity Press.\n\n\nHoning, H. (2018). On the biological basis of musicality. Annals of\nthe New York Academy of Sciences. https://doi.org/10.1111/nyas.13638\n\n\nJan, S. (2016). The Memetics of Music: A\nNeo-Darwinian View of Musical Structure and Culture.\nRoutledge.\n\n\nMcBride, J. M., & Tlusty, T. (2020). Cross-cultural data shows\nmusical scales evolved to maximise imperfect fifths. http://arxiv.org/abs/1906.06171\n\n\nMeyer, L. B. (1989). Style and Music.\nTheory, History, and\nIdeology. University of Chicago Press.\n\n\nMorley, I. (2013). The Prehistory of\nMusic. Human Evolution,\nArchaeology, and the Origins of\nMusicality. Oxford University Press.\n\n\nMoss, F. C., Neuwirth, M., & Rohrmeier, M. (2022). The line of\nfifths and the co-evolution of tonal pitch-classes. Journal of\nMathematics and Music, 1–25. https://doi.org/10.1080/17459737.2022.2044927\n\n\nNakamura, E., & Kaneko, K. (2019). Statistical evolutionary laws in\nmusic styles. Nature Scientific Reports, 9(1), 15993.\nhttps://doi.org/10.1038/s41598-019-52380-6\n\n\nPinker, S. (1997). How the mind works. Norton.\n\n\nSavage, P. E. (2019). Cultural evolution of music. Palgrave\nCommunications, 5(1), 1–16. https://doi.org/10.1057/s41599-019-0221-1\n\n\nStreet, S., Eerola, T., & Kendal, J. R. (2022). The role of\npopulation size in folk tune complexity. Humanities and Social\nSciences Communications, 9(1), 1–12. https://doi.org/10.1057/s41599-022-01139-y\n\n\nTomlinson, G. (2018). A Million Years of\nMusic. Princeton University Press. https://press.princeton.edu/books/paperback/9781890951528/a-million-years-of-music\n\n\nWallin, N. L., Merker, B., & Brown, S. (Eds.). (2001). The\nOrigins of Music. MIT Press.\n\n\nWeiß, C., Mauch, M., Dixon, S., & Müller, M. (2019). Investigating\nstyle evolution of Western classical music: A\ncomputational approach. Musicae Scientiae, 23(4),\n486–507. https://doi.org/10.1177/1029864918757595\n\n\nYoungblood, M., Baraghith, K., & Savage, P. E. (2021). Phylogenetic\nreconstruction of the cultural evolution of electronic music via dynamic\ncommunity detection (1975–1999). Evolution and Human Behavior.\nhttps://doi.org/10.1016/j.evolhumbehav.2021.06.002\n\n\nYoungblood, M., Ozaki, Y., & Savage, P. E. (forthcoming). Cultural\nevolution and music. In J. Tehrani, J. R. Kendal, & R. L. Kendal\n(Eds.), Oxford Handbook of Cultural\nEvolution. Oxford University Press. https://psyarxiv.com/xsb7v"
  }
]